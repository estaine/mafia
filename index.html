<!DOCTYPE html>
<html lang="be">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞ –ú–∞—Ñ—ñ—ñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
            background: #f5f5f5;
            color: #2c2c2c;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            padding: 40px 30px;
            text-align: center;
            border-bottom: 1px solid #34495e;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            color: #ecf0f1;
            letter-spacing: 2px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .header p {
            font-size: 1.1em;
            color: #bdc3c7;
            margin-top: 10px;
            font-weight: 300;
        }

        .back-button {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2em;
            cursor: pointer;
            padding: 10px;
            display: none;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .back-button.show {
            display: flex;
        }

        .header.player-view {
            text-align: left;
            padding-left: 100px;
        }

        .header.player-view h1 {
            font-size: 2em;
        }

        .header.player-view p {
            display: none;
        }

        .status {
            padding: 15px 30px;
            margin: 0;
            font-size: 14px;
            display: none;
            background: #e3f2fd;
            border-left: 3px solid #1976d2;
            color: #0d47a1;
        }

        .status.error {
            background: #ffebee;
            border-left-color: #c62828;
            color: #b71c1c;
        }

        .status.success {
            background: #e8f5e9;
            border-left-color: #388e3c;
            color: #1b5e20;
        }

        .status.show {
            display: block;
        }

        .filters-container {
            background: #f8f9fa;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 20px;
            margin: 20px;
        }

        .filters-title {
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .filters-content {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .filter-row {
            flex: 1;
            min-width: 200px;
            padding: 0 15px;
        }
        
        .filter-row:first-child {
            padding-left: 0;
        }
        
        .filter-row:last-child {
            padding-right: 0;
        }

        .filter-row:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            display: block;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 10px 0;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #d4af37;
        }

        .checkbox-label-text {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 500;
        }

        .player-filter-input-container {
            position: relative;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            background: #ffffff;
            padding: 8px;
            min-height: 42px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            cursor: text;
        }

        .player-filter-input-container:focus-within {
            border-color: #3498db;
            outline: 2px solid rgba(52, 152, 219, 0.2);
        }

        .player-tag {
            display: inline-flex;
            align-items: center;
            background: #3498db;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 13px;
            gap: 6px;
        }

        .player-tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            line-height: 1;
            transition: color 0.2s;
        }

        .player-tag-remove:hover {
            color: #ff6b6b;
        }

        .player-filter-input {
            border: none;
            outline: none;
            flex: 1;
            min-width: 120px;
            font-size: 14px;
            padding: 4px;
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
        }

        .player-filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 250px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            margin-top: 4px;
        }

        .player-filter-dropdown.show {
            display: block;
        }

        .player-filter-item {
            padding: 10px 12px;
            cursor: pointer;
            color: #2c3e50;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
        }

        .player-filter-item:last-child {
            border-bottom: none;
        }

        .player-filter-item:hover,
        .player-filter-item.selected {
            background: #e8eaf6;
        }

        .player-filter-item.disabled {
            color: #95a5a6;
            cursor: not-allowed;
            background: #f8f9fa;
        }

        .slider-container {
            padding: 10px 0;
        }

        .range-slider-wrapper {
            position: relative;
            padding: 10px 0 20px 0;
        }

        .range-slider-track {
            position: relative;
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
        }

        .range-slider-range {
            position: absolute;
            height: 100%;
            background: #3498db;
            border-radius: 3px;
        }

        .range-slider-inputs {
            position: relative;
            width: 100%;
        }

        .range-slider-input {
            position: absolute;
            width: 100%;
            pointer-events: none;
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
            outline: none;
        }

        .range-slider-input::-webkit-slider-thumb {
            pointer-events: all;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #3498db;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .range-slider-input::-webkit-slider-thumb:hover {
            border-color: #2980b9;
            transform: scale(1.1);
        }

        .range-slider-input::-moz-range-thumb {
            pointer-events: all;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #3498db;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .range-slider-input::-moz-range-thumb:hover {
            border-color: #2980b9;
            transform: scale(1.1);
        }

        .range-slider-values {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
            padding: 0 5px;
        }

        .range-slider-value {
            font-size: 16px;
            color: #2c3e50;
            font-weight: 600;
        }

        .filters-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .filters-toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: #7f8c8d;
        }

        .filters-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .filters-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .filters-content.expanded {
            max-height: 500px;
            margin-top: 15px;
        }

        .table-wrapper {
            position: relative;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #ffffff;
        }

        th {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #34495e;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            white-space: nowrap;
            position: relative;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        th:hover {
            background: #34495e;
            color: #ffffff;
        }

        th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.4;
        }

        th.sorted-asc::after {
            content: ' ‚ñ≤';
            opacity: 1;
            color: #ecf0f1;
        }

        th.sorted-desc::after {
            content: ' ‚ñº';
            opacity: 1;
            color: #ecf0f1;
        }

        th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            text-align: left;
            min-width: 150px;
        }

        td {
            padding: 12px 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            color: #2c2c2c;
            font-size: 14px;
        }

        td:first-child {
            position: sticky;
            left: 0;
            background: #f8f9fa;
            font-weight: 600;
            border-right: 1px solid #d0d0d0;
            z-index: 5;
            text-align: left;
            color: #2c3e50;
        }

        tbody tr:nth-child(odd) {
            background: #ffffff;
        }

        tbody tr:nth-child(even) {
            background: #fafafa;
        }

        tbody tr:nth-child(odd) td:first-child {
            background: #f8f9fa;
        }

        tbody tr:nth-child(even) td:first-child {
            background: #f0f1f2;
        }

        tbody tr:hover {
            background: #e8eaf6;
        }

        tbody tr:hover td:first-child {
            background: #dce1e9;
        }

        tbody tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        /* Clickable player cell in partner table */
        .partner-player-cell {
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .partner-player-cell:hover {
            background-color: #e3f2fd !important;
        }

        .partner-player-cell .partner-player-name {
            color: #3498db;
            transition: color 0.2s;
        }

        .partner-player-cell:hover .partner-player-name {
            color: #2980b9;
            text-decoration: underline;
        }

        /* Player Stats Page */
        .player-stats-page {
            display: none;
        }

        .player-stats-page.show {
            display: block;
        }

        .player-stats-header {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px 30px;
            border-bottom: 1px solid #34495e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-stats-header h2 {
            font-size: 1.8em;
            font-weight: 400;
            margin: 0;
            letter-spacing: 1px;
        }

        .player-search-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-search-container {
            position: relative;
        }

        .player-search-input {
            font-size: 1.5em;
            font-weight: 400;
            letter-spacing: 1px;
            padding: 8px 4px;
            border: none;
            border-bottom: 2px solid #ecf0f1;
            background: transparent;
            color: #ecf0f1;
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
            transition: border-color 0.3s;
            min-width: 230px;
        }

        .player-search-input::placeholder {
            color: rgba(236, 240, 241, 0.6);
        }

        .player-search-input:focus {
            outline: none;
            border-bottom-color: #3498db;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #34495e;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1005;
            display: none;
            margin-top: 4px;
        }

        .autocomplete-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .autocomplete-dropdown::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .autocomplete-dropdown::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .autocomplete-dropdown::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 15px;
            cursor: pointer;
            color: #2c3e50;
            font-size: 1.1em;
            border-bottom: 1px solid #e0e0e0;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #e8eaf6;
        }

        .autocomplete-item.no-results {
            cursor: default;
            color: #95a5a6;
            font-style: italic;
        }

        .autocomplete-item.no-results:hover {
            background: #ffffff;
        }

        .compare-btn {
            background: #3498db;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
        }

        .compare-btn:hover {
            background: #2980b9;
        }

        .compare-btn:active {
            transform: scale(0.95);
        }

        .player-search-container.secondary {
            display: none;
        }

        .player-search-container.secondary.show {
            display: block;
        }

        .close-compare-btn {
            background: #e74c3c;
            color: #ffffff;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
        }

        .close-compare-btn:hover {
            background: #c0392b;
            transform: rotate(90deg);
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
            table-layout: fixed;
        }

        .comparison-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
            width: 11%; /* 8 columns √ó 11% = 88% */
        }

        .comparison-table th:first-child {
            text-align: left;
            width: 12%; /* First column is smaller = 12% */
        }

        .comparison-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            width: 11%;
        }

        .comparison-table td:first-child {
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            width: 12%; /* First column is smaller = 12% */
        }

        .comparison-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .comparison-table tr:nth-child(even) {
            background: #ffffff;
        }

        .comparison-table .total-row {
            background: #e8eaf6 !important;
            font-weight: 600;
        }

        .comparison-table .team-row {
            background: #f0f1f2 !important;
            font-weight: 600;
            font-style: italic;
        }

        .player-column-header {
            background: #2c3e50 !important;
            color: #3498db !important;
            font-size: 1.1em;
        }

        .player1-header {
            color: #27ae60 !important;
        }

        .player2-header {
            color: #3498db !important;
        }

        .stat-bar-gold {
            background-color: #f39c12;
        }

        .stat-bar-silver {
            background-color: #95a5a6;
        }

        .stat-bar-green {
            background-color: #27ae60;
        }

        .stat-bar-blue {
            background-color: #3498db;
        }

        .personal-stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .personal-stats-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
            width: 20%;
        }

        .personal-stats-table th:last-child {
            width: 60%;
        }

        .personal-stats-table th:first-child {
            color: #27ae60;
        }

        .personal-stats-table th:nth-child(2) {
            color: #3498db;
            font-weight: bold;
        }

        .personal-stats-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            background: inherit;
        }

        .personal-stats-table td:nth-child(1),
        .personal-stats-table td:nth-child(2) {
            width: 20%;
        }

        .personal-stats-table td:nth-child(3) {
            width: 60%;
        }

        .personal-stats-table tbody tr:nth-child(odd) td {
            background: #f8f9fa;
        }

        .personal-stats-table tbody tr:nth-child(even) td {
            background: #ffffff;
        }

        .personal-stats-table .summary-row td {
            font-weight: 600;
            background: #e8eaf6 !important;
        }

        .personal-stats-table .summary-row td[colspan] {
            text-align: center;
        }

        .stat-bar-grey {
            background-color: #95a5a6;
        }

        .stat-bar-grey:first-child,
        .stat-bar-gold:first-child,
        .stat-bar-green:first-child {
            margin-right: 8px;
            border-radius: 4px;
        }

        .stat-bar-grey:last-child,
        .stat-bar-silver:last-child,
        .stat-bar-blue:last-child {
            margin-left: 8px;
            border-radius: 4px;
        }

        .stat-bar-grey:only-child,
        .stat-bar-gold:only-child,
        .stat-bar-silver:only-child,
        .stat-bar-green:only-child,
        .stat-bar-blue:only-child {
            margin: 0;
            border-radius: 4px;
        }

        .personal-stats-table tbody tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .personal-stats-table tbody tr:nth-child(even) {
            background: #ffffff;
        }

        .personal-stats-table tbody tr:hover {
            background: inherit;
        }

        .personal-stats-table td.highlight {
            background-color: #e8eaf6 !important;
            transition: background-color 0.2s;
        }

        .personal-stats-table .expandable-row {
            cursor: pointer;
        }

        .personal-stats-table .expandable-row:hover td {
            background-color: #e3f2fd !important;
        }

        .personal-stats-table .detail-row {
            display: none;
            background-color: #f5f5f5 !important;
        }

        .personal-stats-table .detail-row.expanded {
            display: table-row;
        }

        .personal-stats-table .detail-row td {
            font-size: 13px;
            color: #555;
        }

        .personal-stats-table .detail-row td.role-detail {
            padding-left: 30px;
        }

        .personal-stats-table .detail-row td:nth-child(2) {
            font-weight: bold;
        }

        .personal-stats-table .detail-row td:nth-child(3) {
            padding: 10px;
        }

        .role-red {
            color: #e74c3c !important;
            font-weight: 600;
        }

        .role-black {
            color: #2c3e50 !important;
            font-weight: 600;
        }

        .expansion-indicator {
            display: inline-block;
            font-size: 10px;
            margin-right: 5px;
            transition: transform 0.2s;
            color: #666;
        }

        .personal-stats-table .expandable-row.expanded .expansion-indicator {
            transform: rotate(0deg);
        }

        .color-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            vertical-align: middle;
        }

        .color-red {
            background-color: #e74c3c;
        }

        .color-black {
            background-color: #2c3e50;
        }

        .stat-bar-container {
            width: 100%;
            height: 30px;
            display: flex;
            border-radius: 4px;
                    overflow: hidden;
                    border: 1px solid #bdc3c7;
            position: relative;
            background: transparent;
        }

        .stat-bar-container.with-connector {
            overflow: visible;
            border: none;
        }

        .stat-bar-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            position: relative;
            z-index: 1;
        }

        .stat-bar-red {
            background-color: #e74c3c;
        }

        .stat-bar-black {
            background-color: #2c3e50;
        }

        .stat-bar-segment {
            cursor: pointer;
        }

        .stat-bar-segment:hover {
            opacity: 0.85;
        }

        .tables-container {
            display: block;
        }

        .table-section {
            width: 100%;
            margin-bottom: 30px;
        }

        .player-stats-body {
            padding: 30px;
        }

        .stats-section {
            margin-bottom: 40px;
        }

        .stats-section h3 {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid #2c3e50;
            padding-bottom: 8px;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .stats-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
        }

        .stats-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
        }

        .stats-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .stats-table tr:nth-child(even) {
            background: #ffffff;
        }

        .stats-table td:first-child {
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
        }

        .stats-table .total-row {
            background: #e8eaf6 !important;
            font-weight: 600;
        }

        .stats-table .team-row {
            background: #f0f1f2 !important;
            font-weight: 600;
            font-style: italic;
        }

        .player-stats-loading {
            text-align: center;
            padding: 50px;
            color: #34495e;
        }

        .games-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .games-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: left;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
        }

        .games-table th:first-child {
            width: 80px;
            text-align: center;
        }

        .games-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }

        .games-table td:first-child {
            text-align: center;
            font-weight: 600;
            color: #7f8c8d;
        }

        .games-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .games-table tr:nth-child(even) {
            background: #ffffff;
        }

        .games-table tr:hover {
            background: #e8eaf6;
        }

        .win-badge {
            color: #27ae60;
            font-weight: 600;
        }

        .loss-badge {
            color: #c0392b;
            font-weight: 600;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            flex-wrap: wrap;
        }

        .pagination-btn {
            background: #2c3e50;
            color: #ecf0f1;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #34495e;
        }

        .pagination-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .pagination-info {
            color: #2c3e50;
            font-weight: 600;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #34495e;
        }

        .spinner {
            border: 4px solid #ecf0f1;
            border-top: 4px solid #34495e;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .win-cell {
            color: #27ae60;
            font-weight: 500;
        }

        .loss-cell {
            color: #c0392b;
        }

        .percentage-cell {
            color: #2c3e50;
            font-weight: 600;
            font-size: 1.05em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }

            .header::before,
            .header::after {
                display: none;
            }

            .header.player-view {
                padding-left: 70px;
            }

            .header.player-view h1 {
                font-size: 1.5em;
            }

            .back-button {
                left: 15px;
                font-size: 1.5em;
                width: 40px;
                height: 40px;
            }

            th, td {
                font-size: 12px;
                padding: 8px 5px;
            }

            .player-search-wrapper {
                flex-wrap: wrap;
                gap: 10px;
            }

            .player-search-input {
                font-size: 1.2em;
                min-width: 180px;
            }

            .compare-btn {
                font-size: 0.8em;
                padding: 6px 12px;
            }

            .player-stats-header {
                padding: 15px 20px;
            }

            .comparison-table th,
            .comparison-table td {
                font-size: 11px;
                padding: 6px 4px;
            }

            .personal-stats-table th,
            .personal-stats-table td {
                font-size: 12px;
                padding: 8px 4px;
            }

            .stat-bar-segment {
                font-size: 11px;
            }

            .pagination {
                gap: 5px;
                padding: 15px 10px;
            }

            .pagination-btn {
                padding: 6px 12px;
                font-size: 12px;
            }

            .pagination-info {
                font-size: 12px;
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" id="header">
            <button class="back-button" id="backButton">‚Üê</button>
            <h1 id="headerTitle">–ú–ê–§–Ü–Ø</h1>
            <p id="headerSubtitle">–°—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞ –≥—É–ª—å—Ü–æ—û</p>
        </div>

        <div class="status" id="status"></div>

        <!-- Filters Section -->
        <div class="filters-container" id="filtersContainer" style="display: none;">
            <div class="filters-toggle" id="filtersToggle">
                <div class="filters-title">–§—ñ–ª—å—Ç—Ä—ã</div>
                <span class="filters-toggle-icon" id="filtersToggleIcon">‚ñº</span>
            </div>
            
            <div class="filters-content" id="filtersContent">
                <div class="filter-row">
                <label class="filter-label">–ì—É–ª—å—Ü—ã:</label>
                <div class="player-filter-input-container" id="playerFilterContainer">
                    <input 
                        type="text" 
                        id="playerFilterInput" 
                        class="player-filter-input" 
                        placeholder="–ü–∞—á–Ω—ñ—Ü–µ –ø—ñ—Å–∞—Ü—å —ñ–º—è –≥—É–ª—å—Ü–∞..."
                        autocomplete="off"
                    />
                    <div class="player-filter-dropdown" id="playerFilterDropdown"></div>
                </div>
            </div>

            <div class="filter-row">
                <label class="filter-label">–ö–æ–ª—å–∫–∞—Å—Ü—å –≥—É–ª—å–Ω—è—û:</label>
                <div class="slider-container">
                    <div class="range-slider-wrapper">
                        <div class="range-slider-track">
                            <div class="range-slider-range" id="sliderRange"></div>
                        </div>
                        <div class="range-slider-inputs">
                            <input 
                                type="range" 
                                id="minGamesSlider" 
                                class="range-slider-input"
                                min="0" 
                                max="100" 
                                value="0"
                                step="1"
                            />
                            <input 
                                type="range" 
                                id="maxGamesSlider" 
                                class="range-slider-input"
                                min="0" 
                                max="100" 
                                value="100"
                                step="1"
                            />
                        </div>
                        <div class="range-slider-values">
                            <div>
                                <div class="range-slider-value" id="minGamesDisplay">0</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="range-slider-value" id="maxGamesDisplay">100</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="filter-row">
                <label class="filter-label">–î–∞—Ç–∞ –≥—É–ª—å–Ω—è—û:</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input 
                        type="text" 
                        id="minDateFilter" 
                        class="player-filter-input" 
                        placeholder="–¥–¥.–º–º.–≥–≥–≥–≥"
                        style="width: 110px; padding: 8px; cursor: pointer;"
                        readonly
                    />
                    <span style="color: #7f8c8d;">‚Äî</span>
                    <input 
                        type="text" 
                        id="maxDateFilter" 
                        class="player-filter-input" 
                        placeholder="–¥–¥.–º–º.–≥–≥–≥–≥"
                        style="width: 110px; padding: 8px; cursor: pointer;"
                        readonly
                    />
                </div>
            </div>

            <div class="filter-row">
                <label class="checkbox-container">
                    <input type="checkbox" id="showHiddenCheckbox" />
                    <span class="checkbox-label-text">–ü–∞–∫–∞–∑–≤–∞—Ü—å —Å—Ö–∞–≤–∞–Ω—ã—Ö</span>
                </label>
            </div>

            <div class="filter-row">
                <label class="checkbox-container">
                    <input type="checkbox" id="onlyActiveCheckbox" />
                    <span class="checkbox-label-text">–¢–æ–ª—å–∫—ñ –∞–∫—Ç—ã—û–Ω—ã—è</span>
                </label>
            </div>
            </div>
        </div>

        <div class="table-wrapper" id="tableWrapper" style="display: none;">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th class="sortable" data-column="name" title="–ì—É–ª–µ—Ü">–ì—É–ª–µ—Ü</th>
                        <th class="sortable" data-column="mPlus" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –º—ñ—Ä–Ω—ã—Ö">–ú+</th>
                        <th class="sortable" data-column="mMinus" title="–ü–∞—Ä–∞–∑—ã –∑–∞ –º—ñ—Ä–Ω—ã—Ö">–ú-</th>
                        <th class="sortable" data-column="shPlus" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —à—ç—Ä—ã—Ñ–∞">–®+</th>
                        <th class="sortable" data-column="shMinus" title="–ü–∞—Ä–∞–∑—ã –∑–∞ —à—ç—Ä—ã—Ñ–∞">–®-</th>
                        <th class="sortable" data-column="mfPlus" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –º–∞—Ñ—ñ—é">–ú—Ñ+</th>
                        <th class="sortable" data-column="mfMinus" title="–ü–∞—Ä–∞–∑—ã –∑–∞ –º–∞—Ñ—ñ—é">–ú—Ñ-</th>
                        <th class="sortable" data-column="dPlus" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –¥–æ–Ω–∞">–î+</th>
                        <th class="sortable" data-column="dMinus" title="–ü–∞—Ä–∞–∑—ã –∑–∞ –¥–æ–Ω–∞">–î-</th>
                        <th class="sortable" data-column="redWins" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö"><span class="color-indicator color-red"></span>+</th>
                        <th class="sortable" data-column="redLosses" title="–ü–∞—Ä–∞–∑—ã –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö"><span class="color-indicator color-red"></span>-</th>
                        <th class="sortable" data-column="red" title="–ê–≥—É–ª–∞–º –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö"><span class="color-indicator color-red"></span></th>
                        <th class="sortable" data-column="redPct" title="–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥ –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö"><span class="color-indicator color-red"></span> %</th>
                        <th class="sortable" data-column="blackWins" title="–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —á–æ—Ä–Ω—ã—Ö"><span class="color-indicator color-black"></span>+</th>
                        <th class="sortable" data-column="blackLosses" title="–ü–∞—Ä–∞–∑—ã –∑–∞ —á–æ—Ä–Ω—ã—Ö"><span class="color-indicator color-black"></span>-</th>
                        <th class="sortable" data-column="black" title="–ê–≥—É–ª–∞–º –∑–∞ —á–æ—Ä–Ω—ã—Ö"><span class="color-indicator color-black"></span></th>
                        <th class="sortable" data-column="blackPct" title="–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥ –∑–∞ —á–æ—Ä–Ω—ã—Ö"><span class="color-indicator color-black"></span> %</th>
                        <th class="sortable" data-column="totalWins" title="–£—Å—è–≥–æ –ø–µ—Ä–∞–º–æ–≥">+</th>
                        <th class="sortable" data-column="totalLosses" title="–£—Å—è–≥–æ –ø–∞—Ä–∞–∑">-</th>
                        <th class="sortable" data-column="total" title="–£—Å—è–≥–æ –≥—É–ª—å–Ω—è—û">–£—Å—è–≥–æ</th>
                        <th class="sortable" data-column="winPct" title="–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥">%</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>

        <!-- Player Stats Page -->
        <div class="player-stats-page" id="playerStatsPage">
            <div class="player-stats-header">
                <div class="player-search-wrapper">
                    <div class="player-search-container">
                        <input 
                            type="text" 
                            id="playerSearchInput" 
                            class="player-search-input" 
                            placeholder="–£–≤—è–¥–∑—ñ—Ü–µ —ñ–º—è –≥—É–ª—å—Ü–∞..."
                            autocomplete="off"
                        />
                        <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                    </div>
                    <button class="compare-btn" id="compareBtn">–ü–∞—Ä–∞—û–Ω–∞—Ü—å</button>
                    <div class="player-search-container secondary" id="secondarySearchContainer">
                        <input 
                            type="text" 
                            id="playerSearchInput2" 
                            class="player-search-input" 
                            placeholder="–í—ã–±–µ—Ä—ã—Ü–µ –¥—Ä—É–≥–æ–≥–∞ –≥—É–ª—å—Ü–∞"
                            autocomplete="off"
                        />
                        <div class="autocomplete-dropdown" id="autocompleteDropdown2"></div>
                    </div>
                    <button class="close-compare-btn" id="closeCompareBtn" style="display: none;">&times;</button>
                </div>
            </div>
            <div class="player-stats-body" id="playerStatsBody">
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç—ã—Å—Ç—ã–∫—ñ...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://mpasyybxqvzbnxciejqo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1wYXN5eWJ4cXZ6Ym54Y2llanFvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc2MTM5NjAsImV4cCI6MjA4MzE4OTk2MH0.W6OWShmcUwkFgCIRZfeGls0qM7bIFFzcBU06JsKy_cQ';

        let playerData = [];
        let filteredPlayerData = [];
        let allGamesData = [];
        let currentSort = { column: 'name', ascending: true };
        let selectedPlayers = [];
        let filterMinGames = 0;
        let filterMaxGames = 100;
        let maxGamesInData = 100;
        let defaultMinGamesThreshold = 25; // Will be loaded from DB
        let filterMinDate = '';
        let filterMaxDate = '';
        let playerFilterSelectedIndex = -1;
        let playerFilterItems = [];
        let showHiddenPlayers = false; // Track checkbox state for hidden players
        let activityPeriodDays = 30; // Will be loaded from DB
        let onlyActivePlayersFilter = false; // Track checkbox state for active players filter
        let lastGameDate = null; // Track most recent game date

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status show ' + type;
        }

        function mapSupabaseData(dbRow) {
            return {
                name: dbRow.name || '',
                mPlus: dbRow.m_plus || 0,
                mMinus: dbRow.m_minus || 0,
                shPlus: dbRow.sh_plus || 0,
                shMinus: dbRow.sh_minus || 0,
                mfPlus: dbRow.mf_plus || 0,
                mfMinus: dbRow.mf_minus || 0,
                dPlus: dbRow.d_plus || 0,
                dMinus: dbRow.d_minus || 0,
                red: dbRow.red_games || 0,
                black: dbRow.black_games || 0,
                total: dbRow.total_games || 0,
                winPct: parseFloat(dbRow.win_pct) || 0,
                isHidden: dbRow.is_hidden || false
            };
        }

        function sortData(column) {
            if (currentSort.column === column) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = column;
                currentSort.ascending = false; // Default to descending for better stats first
            }

            sortFilteredData();
            displayTable();
            updateSortIndicators();
        }

        function updateSortIndicators() {
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            const sortedTh = document.querySelector(`th[data-column="${currentSort.column}"]`);
            if (sortedTh) {
                sortedTh.classList.add(currentSort.ascending ? 'sorted-asc' : 'sorted-desc');
            }
        }

        function calculatePlayerDataFromGames(games) {
            const playerStatsMap = {};
            let globalLastDate = null;
            
            games.forEach(game => {
                const playerName = game.player_name;
                const gameDate = game.game_date;
                
                if (!playerStatsMap[playerName]) {
                    playerStatsMap[playerName] = {
                        name: playerName,
                        mPlus: 0, mMinus: 0,
                        shPlus: 0, shMinus: 0,
                        mfPlus: 0, mfMinus: 0,
                        dPlus: 0, dMinus: 0,
                        red: 0, black: 0,
                        redWins: 0, redLosses: 0,
                        blackWins: 0, blackLosses: 0,
                        total: 0,
                        totalWins: 0, totalLosses: 0,
                        isHidden: false,  // Default value, will be updated
                        lastPlayedDate: null  // Track last played date for this player
                    };
                }
                
                const stats = playerStatsMap[playerName];
                const won = game.player_won;
                const role = game.role_code;
                const isRed = (role === 'M' || role === 'Sh');
                
                // Track last played date for this player
                if (gameDate) {
                    const gameDateStr = gameDate.split('T')[0]; // Get YYYY-MM-DD part
                    if (!stats.lastPlayedDate || gameDateStr > stats.lastPlayedDate) {
                        stats.lastPlayedDate = gameDateStr;
                    }
                    
                    // Track global last game date
                    if (!globalLastDate || gameDateStr > globalLastDate) {
                        globalLastDate = gameDateStr;
                    }
                }
                
                // Update role stats
                if (role === 'M') {
                    won ? stats.mPlus++ : stats.mMinus++;
                } else if (role === 'Sh') {
                    won ? stats.shPlus++ : stats.shMinus++;
                } else if (role === 'Mf') {
                    won ? stats.mfPlus++ : stats.mfMinus++;
                } else if (role === 'D') {
                    won ? stats.dPlus++ : stats.dMinus++;
                }
                
                // Update team stats
                if (isRed) {
                    stats.red++;
                    if (won) {
                        stats.redWins++;
                    } else {
                        stats.redLosses++;
                    }
                } else {
                    stats.black++;
                    if (won) {
                        stats.blackWins++;
                    } else {
                        stats.blackLosses++;
                    }
                }
                
                // Update totals
                stats.total++;
                if (won) {
                    stats.totalWins++;
                } else {
                    stats.totalLosses++;
                }
            });
            
            // Update global last game date
            lastGameDate = globalLastDate;
            console.log('üìÖ Last game date:', lastGameDate);
            
            // Convert to array and calculate win percentages
            return Object.values(playerStatsMap).map(stats => ({
                ...stats,
                redPct: stats.red > 0 ? (stats.redWins / stats.red * 100) : 0,
                blackPct: stats.black > 0 ? (stats.blackWins / stats.black * 100) : 0,
                winPct: stats.total > 0 ? (stats.totalWins / stats.total * 100) : 0
            }));
        }

        // Fetch player hidden statuses and merge into player data
        async function enrichPlayerDataWithHiddenStatus(playerData) {
            try {
                const apiUrl = `${SUPABASE_URL}/rest/v1/player?select=name,is_hidden`;
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to fetch player hidden statuses');
                    return playerData;
                }
                
                const players = await response.json();
                const hiddenMap = {};
                players.forEach(p => {
                    hiddenMap[p.name] = p.is_hidden || false;
                });
                
                // Merge hidden status into player data
                return playerData.map(player => ({
                    ...player,
                    isHidden: hiddenMap[player.name] || false
                }));
            } catch (error) {
                console.error('Error enriching player data:', error);
                return playerData;
            }
        }

        function applyFilters() {
            console.log('Applying filters...', {
                filterMinDate,
                filterMaxDate,
                totalGames: allGamesData.length,
                filterMinGames,
                filterMaxGames,
                selectedPlayers
            });
            
            // First, filter games by date range
            let filteredGames = allGamesData;
            
            if (filterMinDate || filterMaxDate) {
                filteredGames = allGamesData.filter(game => {
                    if (!game.game_date) return true;
                    const gameDate = game.game_date.split('T')[0]; // Get YYYY-MM-DD part
                    
                    if (filterMinDate && gameDate < filterMinDate) return false;
                    if (filterMaxDate && gameDate > filterMaxDate) return false;
                    
                    return true;
                });
                console.log('After date filter:', filteredGames.length, 'games');
            }
            
            // Preserve hidden status before recalculation
            const hiddenStatusMap = {};
            playerData.forEach(p => {
                hiddenStatusMap[p.name] = p.isHidden || false;
            });
            
            // Recalculate player data from filtered games
            playerData = calculatePlayerDataFromGames(filteredGames);
            
            // Restore hidden status
            playerData.forEach(p => {
                p.isHidden = hiddenStatusMap[p.name] || false;
            });
            
            console.log('After recalc:', playerData.length, 'players');
            
            // Then filter by player names and game count
            filteredPlayerData = playerData.filter(player => {
                // Filter by selected players (if any)
                if (selectedPlayers.length > 0 && !selectedPlayers.includes(player.name)) {
                    return false;
                }
                
                // Filter by minimum and maximum games
                if (player.total < filterMinGames || player.total > filterMaxGames) {
                    return false;
                }
                
                // Filter by hidden status (only when checkbox is unchecked)
                if (!showHiddenPlayers && player.isHidden) {
                    return false;
                }
                
                // Filter by activity period (only when checkbox is checked)
                if (onlyActivePlayersFilter && lastGameDate && player.lastPlayedDate) {
                    // Calculate cutoff date: lastGameDate - activityPeriodDays
                    const lastDate = new Date(lastGameDate);
                    const cutoffDate = new Date(lastDate);
                    cutoffDate.setDate(cutoffDate.getDate() - activityPeriodDays);
                    const cutoffDateStr = cutoffDate.toISOString().split('T')[0];
                    
                    // Filter out players whose last played date is before cutoff
                    if (player.lastPlayedDate < cutoffDateStr) {
                        return false;
                    }
                }
                
                return true;
            });
            
            console.log('Final filtered players:', filteredPlayerData.length);
            
            // Re-apply the current sort to maintain order
            sortFilteredData();
            displayTable();
        }

        function sortFilteredData() {
            const column = currentSort.column;
            const ascending = currentSort.ascending;

            filteredPlayerData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // For name, use string comparison
                if (column === 'name') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                    return ascending ? 
                        aVal.localeCompare(bVal) : 
                        bVal.localeCompare(aVal);
                }

                // For numbers
                return ascending ? 
                    aVal - bVal : 
                    bVal - aVal;
            });
        }

        function displayTable() {
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';

            filteredPlayerData.forEach(player => {
                const tr = document.createElement('tr');
                
                // Add click handler for player stats
                tr.addEventListener('click', () => {
                    showPlayerStats(player.name);
                });
                
                // Player name
                const tdName = document.createElement('td');
                tdName.textContent = player.name;
                tr.appendChild(tdName);

                // M+
                const tdMPlus = document.createElement('td');
                tdMPlus.textContent = player.mPlus;
                tdMPlus.className = 'win-cell';
                tdMPlus.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –º—ñ—Ä–Ω—ã—Ö';
                tr.appendChild(tdMPlus);

                // M-
                const tdMMinus = document.createElement('td');
                tdMMinus.textContent = player.mMinus;
                tdMMinus.className = 'loss-cell';
                tdMMinus.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ –º—ñ—Ä–Ω—ã—Ö';
                tr.appendChild(tdMMinus);

                // Sh+
                const tdShPlus = document.createElement('td');
                tdShPlus.textContent = player.shPlus;
                tdShPlus.className = 'win-cell';
                tdShPlus.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —à—ç—Ä—ã—Ñ–∞';
                tr.appendChild(tdShPlus);

                // Sh-
                const tdShMinus = document.createElement('td');
                tdShMinus.textContent = player.shMinus;
                tdShMinus.className = 'loss-cell';
                tdShMinus.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ —à—ç—Ä—ã—Ñ–∞';
                tr.appendChild(tdShMinus);

                // Mf+
                const tdMfPlus = document.createElement('td');
                tdMfPlus.textContent = player.mfPlus;
                tdMfPlus.className = 'win-cell';
                tdMfPlus.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –º–∞—Ñ—ñ—é';
                tr.appendChild(tdMfPlus);

                // Mf-
                const tdMfMinus = document.createElement('td');
                tdMfMinus.textContent = player.mfMinus;
                tdMfMinus.className = 'loss-cell';
                tdMfMinus.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ –º–∞—Ñ—ñ—é';
                tr.appendChild(tdMfMinus);

                // D+
                const tdDPlus = document.createElement('td');
                tdDPlus.textContent = player.dPlus;
                tdDPlus.className = 'win-cell';
                tdDPlus.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ –¥–æ–Ω–∞';
                tr.appendChild(tdDPlus);

                // D-
                const tdDMinus = document.createElement('td');
                tdDMinus.textContent = player.dMinus;
                tdDMinus.className = 'loss-cell';
                tdDMinus.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ –¥–æ–Ω–∞';
                tr.appendChild(tdDMinus);

                // Red wins
                const tdRedWins = document.createElement('td');
                tdRedWins.textContent = player.redWins;
                tdRedWins.className = 'win-cell';
                tdRedWins.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö';
                tr.appendChild(tdRedWins);

                // Red losses
                const tdRedLosses = document.createElement('td');
                tdRedLosses.textContent = player.redLosses;
                tdRedLosses.className = 'loss-cell';
                tdRedLosses.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö';
                tr.appendChild(tdRedLosses);

                // Red team
                const tdRed = document.createElement('td');
                tdRed.textContent = player.red;
                tdRed.title = '–ê–≥—É–ª–∞–º –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö';
                tr.appendChild(tdRed);

                // Red percentage
                const tdRedPct = document.createElement('td');
                tdRedPct.textContent = player.redPct.toFixed(1) + '%';
                tdRedPct.className = 'percentage-cell';
                tdRedPct.title = '–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥ –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö';
                tr.appendChild(tdRedPct);

                // Black wins
                const tdBlackWins = document.createElement('td');
                tdBlackWins.textContent = player.blackWins;
                tdBlackWins.className = 'win-cell';
                tdBlackWins.title = '–ü–µ—Ä–∞–º–æ–≥—ñ –∑–∞ —á–æ—Ä–Ω—ã—Ö';
                tr.appendChild(tdBlackWins);

                // Black losses
                const tdBlackLosses = document.createElement('td');
                tdBlackLosses.textContent = player.blackLosses;
                tdBlackLosses.className = 'loss-cell';
                tdBlackLosses.title = '–ü–∞—Ä–∞–∑—ã –∑–∞ —á–æ—Ä–Ω—ã—Ö';
                tr.appendChild(tdBlackLosses);

                // Black team
                const tdBlack = document.createElement('td');
                tdBlack.textContent = player.black;
                tdBlack.title = '–ê–≥—É–ª–∞–º –∑–∞ —á–æ—Ä–Ω—ã—Ö';
                tr.appendChild(tdBlack);

                // Black percentage
                const tdBlackPct = document.createElement('td');
                tdBlackPct.textContent = player.blackPct.toFixed(1) + '%';
                tdBlackPct.className = 'percentage-cell';
                tdBlackPct.title = '–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥ –∑–∞ —á–æ—Ä–Ω—ã—Ö';
                tr.appendChild(tdBlackPct);

                // Total wins
                const tdTotalWins = document.createElement('td');
                tdTotalWins.textContent = player.totalWins;
                tdTotalWins.className = 'win-cell';
                tdTotalWins.style.fontWeight = 'bold';
                tdTotalWins.title = '–£—Å—è–≥–æ –ø–µ—Ä–∞–º–æ–≥';
                tr.appendChild(tdTotalWins);

                // Total losses
                const tdTotalLosses = document.createElement('td');
                tdTotalLosses.textContent = player.totalLosses;
                tdTotalLosses.className = 'loss-cell';
                tdTotalLosses.style.fontWeight = 'bold';
                tdTotalLosses.title = '–£—Å—è–≥–æ –ø–∞—Ä–∞–∑';
                tr.appendChild(tdTotalLosses);

                // Total games
                const tdTotal = document.createElement('td');
                tdTotal.textContent = player.total;
                tdTotal.className = 'total-cell';
                tdTotal.style.fontWeight = 'bold';
                tdTotal.title = '–£—Å—è–≥–æ –≥—É–ª—å–Ω—è—û';
                tr.appendChild(tdTotal);

                // Win percentage
                const tdPct = document.createElement('td');
                tdPct.textContent = player.winPct.toFixed(1) + '%';
                tdPct.className = 'percentage-cell';
                tdPct.title = '–ê–¥—Å–æ—Ç–∞–∫ –ø–µ—Ä–∞–º–æ–≥';
                tr.appendChild(tdPct);

                tableBody.appendChild(tr);
            });
        }

        // Role code to Belarusian name mapping
        const roleNames = {
            'M': '–ú—ñ—Ä–Ω—ã –∂—ã—Ö–∞—Ä',
            'Sh': '–®—ç—Ä—ã—Ñ',
            'Mf': '–ú–∞—Ñ—ñ—è',
            'D': '–î–æ–Ω'
        };

        // Autocomplete state
        let autocompleteSelectedIndex = -1;
        let autocompleteItems = [];
        let autocompleteSelectedIndex2 = -1;
        let autocompleteItems2 = [];
        
        // Comparison mode state
        let comparisonMode = false;
        let selectedPlayer1 = null;
        let selectedPlayer2 = null;

        // Partner/Opponent table state
        let partnerTableData = [];
        let partnerTableSort = { column: 'totalTotal', ascending: false };

        // Navigation Control Functions
        function showPlayerStatsView() {
            // Hide table view and filters
            document.getElementById('tableWrapper').style.display = 'none';
            document.getElementById('filtersContainer').style.display = 'none';
            
            // Show player stats page
            document.getElementById('playerStatsPage').classList.add('show');
            
            // Update header
            const header = document.getElementById('header');
            const backButton = document.getElementById('backButton');
            const headerTitle = document.getElementById('headerTitle');
            const headerSubtitle = document.getElementById('headerSubtitle');
            
            header.classList.add('player-view');
            backButton.classList.add('show');
            headerSubtitle.style.display = 'none';
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function showMainTableView() {
            // Show table view and filters
            document.getElementById('tableWrapper').style.display = 'block';
            document.getElementById('filtersContainer').style.display = 'block';
            
            // Hide player stats page
            document.getElementById('playerStatsPage').classList.remove('show');
            
            // Update header
            const header = document.getElementById('header');
            const backButton = document.getElementById('backButton');
            const headerTitle = document.getElementById('headerTitle');
            const headerSubtitle = document.getElementById('headerSubtitle');
            
            header.classList.remove('player-view');
            backButton.classList.remove('show');
            headerTitle.textContent = '–ú–ê–§–Ü–Ø';
            headerSubtitle.style.display = 'block';
            
            closeAutocomplete();
            closeAutocomplete2();
            
            // Reset comparison mode
            comparisonMode = false;
            selectedPlayer1 = null;
            selectedPlayer2 = null;
            document.getElementById('secondarySearchContainer').classList.remove('show');
            document.getElementById('closeCompareBtn').style.display = 'none';
            document.getElementById('compareBtn').style.display = 'block';
            document.getElementById('playerSearchInput2').value = '';
            document.getElementById('playerSearchInput').value = '';
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function closeAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.classList.remove('show');
            autocompleteSelectedIndex = -1;
            autocompleteItems = [];
        }

        function closeAutocomplete2() {
            const dropdown = document.getElementById('autocompleteDropdown2');
            dropdown.classList.remove('show');
            autocompleteSelectedIndex2 = -1;
            autocompleteItems2 = [];
        }

        // Filter players by search term
        function filterPlayers(searchTerm, excludePlayer = null) {
            let filtered = playerData;
            if (excludePlayer) {
                filtered = filtered.filter(player => player.name !== excludePlayer);
            }
            if (!searchTerm) return filtered;
            const term = searchTerm.toLowerCase();
            return filtered.filter(player => 
                player.name.toLowerCase().includes(term)
            );
        }

        // Render autocomplete dropdown
        function renderAutocomplete(filteredPlayers, isSecondary = false) {
            const dropdownId = isSecondary ? 'autocompleteDropdown2' : 'autocompleteDropdown';
            const dropdown = document.getElementById(dropdownId);
            const selectedIndex = isSecondary ? autocompleteSelectedIndex2 : autocompleteSelectedIndex;
            
            if (filteredPlayers.length === 0) {
                dropdown.innerHTML = '<div class="autocomplete-item no-results">–ù—ñ—á–æ–≥–∞ –Ω–µ –∑–Ω–æ–π–¥–∑–µ–Ω–∞</div>';
                dropdown.classList.add('show');
                return;
            }

            if (isSecondary) {
                autocompleteItems2 = filteredPlayers;
            } else {
                autocompleteItems = filteredPlayers;
            }

            const items = filteredPlayers.map((player, index) => {
                const className = index === selectedIndex ? 'autocomplete-item selected' : 'autocomplete-item';
                return `<div class="${className}" data-index="${index}" data-name="${player.name}">${player.name}</div>`;
            }).join('');

            dropdown.innerHTML = items;
            dropdown.classList.add('show');

            // Add click handlers to items
            dropdown.querySelectorAll('.autocomplete-item:not(.no-results)').forEach(item => {
                item.addEventListener('click', (e) => {
                    const playerName = e.target.dataset.name;
                    if (isSecondary) {
                        selectPlayer2(playerName);
                    } else {
                        selectPlayer(playerName);
                    }
                });
            });

            // Scroll selected item into view
            if (selectedIndex >= 0) {
                const selectedItem = dropdown.querySelector('.autocomplete-item.selected');
                if (selectedItem) {
                    selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
        }

        // Select a player from autocomplete
        function selectPlayer(playerName) {
            const input = document.getElementById('playerSearchInput');
            input.value = playerName;
            closeAutocomplete();
            selectedPlayer1 = playerName;
            
            if (comparisonMode && selectedPlayer2) {
                showComparisonStats(selectedPlayer1, selectedPlayer2);
            } else if (!comparisonMode) {
                showPlayerStats(playerName);
            }
        }

        // Select second player from autocomplete
        function selectPlayer2(playerName) {
            const input = document.getElementById('playerSearchInput2');
            input.value = playerName;
            closeAutocomplete2();
            selectedPlayer2 = playerName;
            
            if (selectedPlayer1) {
                showComparisonStats(selectedPlayer1, selectedPlayer2);
            }
        }

        // Handle autocomplete input for first player
        const playerSearchInput = document.getElementById('playerSearchInput');
        playerSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.trim();
            if (searchTerm.length === 0) {
                closeAutocomplete();
                return;
            }
            // Exclude player 2 if in comparison mode
            const excludePlayer = comparisonMode ? selectedPlayer2 : null;
            const filtered = filterPlayers(searchTerm, excludePlayer);
            renderAutocomplete(filtered, false);
        });

        // Handle autocomplete input for second player
        const playerSearchInput2 = document.getElementById('playerSearchInput2');
        playerSearchInput2.addEventListener('input', (e) => {
            const searchTerm = e.target.value.trim();
            if (searchTerm.length === 0) {
                closeAutocomplete2();
                return;
            }
            const filtered = filterPlayers(searchTerm, selectedPlayer1);
            renderAutocomplete(filtered, true);
        });

        // Handle keyboard navigation in first autocomplete
        playerSearchInput.addEventListener('keydown', (e) => {
            const dropdown = document.getElementById('autocompleteDropdown');
            
            if (e.key === 'Escape') {
                e.preventDefault();
                if (dropdown.classList.contains('show')) {
                    closeAutocomplete();
                } else {
                    showMainTableView();
                }
                return;
            }

            if (!dropdown.classList.contains('show')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, autocompleteItems.length - 1);
                renderAutocomplete(autocompleteItems, false);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                renderAutocomplete(autocompleteItems, false);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteSelectedIndex >= 0 && autocompleteItems[autocompleteSelectedIndex]) {
                    selectPlayer(autocompleteItems[autocompleteSelectedIndex].name);
                } else if (autocompleteItems.length === 1) {
                    selectPlayer(autocompleteItems[0].name);
                }
            }
        });

        // Handle keyboard navigation in second autocomplete
        playerSearchInput2.addEventListener('keydown', (e) => {
            const dropdown = document.getElementById('autocompleteDropdown2');
            
            if (e.key === 'Escape') {
                e.preventDefault();
                if (dropdown.classList.contains('show')) {
                    closeAutocomplete2();
                }
                return;
            }

            if (!dropdown.classList.contains('show')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                autocompleteSelectedIndex2 = Math.min(autocompleteSelectedIndex2 + 1, autocompleteItems2.length - 1);
                renderAutocomplete(autocompleteItems2, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                autocompleteSelectedIndex2 = Math.max(autocompleteSelectedIndex2 - 1, -1);
                renderAutocomplete(autocompleteItems2, true);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteSelectedIndex2 >= 0 && autocompleteItems2[autocompleteSelectedIndex2]) {
                    selectPlayer2(autocompleteItems2[autocompleteSelectedIndex2].name);
                } else if (autocompleteItems2.length === 1) {
                    selectPlayer2(autocompleteItems2[0].name);
                }
            }
        });

        // Close autocomplete when clicking outside
        document.addEventListener('click', (e) => {
            const searchContainers = document.querySelectorAll('.player-search-container');
            let clickedInside = false;
            searchContainers.forEach(container => {
                if (container.contains(e.target)) {
                    clickedInside = true;
                }
            });
            if (!clickedInside) {
                closeAutocomplete();
                closeAutocomplete2();
            }
            
            // Close player filter dropdown when clicking outside
            const playerFilterContainer = document.getElementById('playerFilterContainer');
            if (playerFilterContainer && !playerFilterContainer.contains(e.target)) {
                closePlayerFilterDropdown();
            }
        });

        // Player filter functions
        function closePlayerFilterDropdown() {
            const dropdown = document.getElementById('playerFilterDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                playerFilterSelectedIndex = -1;
                playerFilterItems = [];
            }
        }

        function renderPlayerFilterDropdown(filteredPlayers) {
            const dropdown = document.getElementById('playerFilterDropdown');
            
            if (filteredPlayers.length === 0) {
                dropdown.innerHTML = '<div class="player-filter-item disabled">–ù—ñ—á–æ–≥–∞ –Ω–µ –∑–Ω–æ–π–¥–∑–µ–Ω–∞</div>';
                dropdown.classList.add('show');
                return;
            }

            playerFilterItems = filteredPlayers;

            const items = filteredPlayers.map((player, index) => {
                const isSelected = selectedPlayers.includes(player.name);
                const className = index === playerFilterSelectedIndex ? 
                    'player-filter-item selected' : 
                    'player-filter-item';
                const disabledClass = isSelected ? ' disabled' : '';
                return `<div class="${className}${disabledClass}" data-index="${index}" data-name="${player.name}">${player.name}${isSelected ? ' (–≤—ã–±—Ä–∞–Ω–∞)' : ''}</div>`;
            }).join('');

            dropdown.innerHTML = items;
            dropdown.classList.add('show');

            // Add click handlers
            dropdown.querySelectorAll('.player-filter-item:not(.disabled)').forEach(item => {
                item.addEventListener('click', (e) => {
                    const playerName = e.target.dataset.name;
                    if (!selectedPlayers.includes(playerName)) {
                        addPlayerTag(playerName);
                    }
                });
            });

            // Scroll selected item into view
            if (playerFilterSelectedIndex >= 0) {
                const selectedItem = dropdown.querySelector('.player-filter-item.selected');
                if (selectedItem) {
                    selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
        }

        function addPlayerTag(playerName) {
            if (selectedPlayers.includes(playerName)) return;
            
            selectedPlayers.push(playerName);
            renderPlayerTags();
            
            const input = document.getElementById('playerFilterInput');
            input.value = '';
            closePlayerFilterDropdown();
            
            applyFilters();
        }

        function removePlayerTag(playerName) {
            selectedPlayers = selectedPlayers.filter(p => p !== playerName);
            renderPlayerTags();
            applyFilters();
        }

        function renderPlayerTags() {
            const container = document.getElementById('playerFilterContainer');
            const input = document.getElementById('playerFilterInput');
            
            // Remove existing tags
            container.querySelectorAll('.player-tag').forEach(tag => tag.remove());
            
            // Add new tags before the input
            selectedPlayers.forEach(playerName => {
                const tag = document.createElement('span');
                tag.className = 'player-tag';
                tag.innerHTML = `
                    ${playerName}
                    <span class="player-tag-remove" data-name="${playerName}">&times;</span>
                `;
                container.insertBefore(tag, input);
                
                // Add click handler to remove button
                tag.querySelector('.player-tag-remove').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removePlayerTag(e.target.dataset.name);
                });
            });
        }

        // Player filter input handler
        function setupPlayerFilter() {
            const input = document.getElementById('playerFilterInput');
            const container = document.getElementById('playerFilterContainer');
            
            // Focus input when clicking on container
            container.addEventListener('click', (e) => {
                if (e.target === container || e.target === input) {
                    input.focus();
                }
            });
            
            // Handle input
            input.addEventListener('input', (e) => {
                const searchTerm = e.target.value.trim();
                if (searchTerm.length === 0) {
                    closePlayerFilterDropdown();
                    return;
                }
                
                // Filter players excluding already selected ones
                const filtered = playerData.filter(player => 
                    !selectedPlayers.includes(player.name) &&
                    player.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
                
                renderPlayerFilterDropdown(filtered);
            });
            
            // Handle keyboard navigation
            input.addEventListener('keydown', (e) => {
                const dropdown = document.getElementById('playerFilterDropdown');
                
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closePlayerFilterDropdown();
                    input.blur();
                    return;
                }

                if (!dropdown.classList.contains('show')) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    playerFilterSelectedIndex = Math.min(playerFilterSelectedIndex + 1, playerFilterItems.length - 1);
                    renderPlayerFilterDropdown(playerFilterItems);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    playerFilterSelectedIndex = Math.max(playerFilterSelectedIndex - 1, -1);
                    renderPlayerFilterDropdown(playerFilterItems);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (playerFilterSelectedIndex >= 0 && playerFilterItems[playerFilterSelectedIndex]) {
                        const playerName = playerFilterItems[playerFilterSelectedIndex].name;
                        if (!selectedPlayers.includes(playerName)) {
                            addPlayerTag(playerName);
                        }
                    } else if (playerFilterItems.length === 1) {
                        const playerName = playerFilterItems[0].name;
                        if (!selectedPlayers.includes(playerName)) {
                            addPlayerTag(playerName);
                        }
                    }
                }
            });
        }

        // Toggle filters visibility
        function setupFiltersToggle() {
            const toggle = document.getElementById('filtersToggle');
            const content = document.getElementById('filtersContent');
            const icon = document.getElementById('filtersToggleIcon');
            
            toggle.addEventListener('click', () => {
                content.classList.toggle('expanded');
                icon.classList.toggle('expanded');
            });
        }

        // Games filter handlers
        function setupGamesFilter() {
            const minSlider = document.getElementById('minGamesSlider');
            const maxSlider = document.getElementById('maxGamesSlider');
            const minDisplay = document.getElementById('minGamesDisplay');
            const maxDisplay = document.getElementById('maxGamesDisplay');
            const sliderRange = document.getElementById('sliderRange');
            
            // Calculate max games from data
            maxGamesInData = Math.max(...playerData.map(p => p.total));
            
            // Set slider attributes
            minSlider.min = 0;
            minSlider.max = maxGamesInData;
            maxSlider.min = 0;
            maxSlider.max = maxGamesInData;
            
            // Set initial values using threshold from DB
            filterMinGames = Math.min(defaultMinGamesThreshold, maxGamesInData);
            filterMaxGames = maxGamesInData;
            minSlider.value = filterMinGames;
            maxSlider.value = filterMaxGames;
            minDisplay.textContent = filterMinGames;
            maxDisplay.textContent = filterMaxGames;
            
            updateSliderRange();
            applyFilters(); // Apply initial filter with default values
            
            // Handle min slider
            minSlider.addEventListener('input', () => {
                let minValue = parseInt(minSlider.value);
                let maxValue = parseInt(maxSlider.value);
                
                // Ensure min doesn't exceed max
                if (minValue > maxValue) {
                    minValue = maxValue;
                    minSlider.value = minValue;
                }
                
                filterMinGames = minValue;
                minDisplay.textContent = minValue;
                updateSliderRange();
                applyFilters();
            });
            
            // Handle max slider
            maxSlider.addEventListener('input', () => {
                let minValue = parseInt(minSlider.value);
                let maxValue = parseInt(maxSlider.value);
                
                // Ensure max doesn't go below min
                if (maxValue < minValue) {
                    maxValue = minValue;
                    maxSlider.value = maxValue;
                }
                
                filterMaxGames = maxValue;
                maxDisplay.textContent = maxValue;
                updateSliderRange();
                applyFilters();
            });
        }
        
        function updateSliderRange() {
            const sliderRange = document.getElementById('sliderRange');
            const minPercent = (filterMinGames / maxGamesInData) * 100;
            const maxPercent = (filterMaxGames / maxGamesInData) * 100;
            
            sliderRange.style.left = minPercent + '%';
            sliderRange.style.width = (maxPercent - minPercent) + '%';
        }

        // Date filter handlers
        async function setupDateFilter() {
            const minDateInput = document.getElementById('minDateFilter');
            const maxDateInput = document.getElementById('maxDateFilter');
            
            // Helper function to convert yyyy-MM-dd to dd.MM.yyyy
            const formatDateDisplay = (isoDate) => {
                const [year, month, day] = isoDate.split('-');
                return `${day}.${month}.${year}`;
            };
            
            // Helper function to convert dd.MM.yyyy to yyyy-MM-dd
            const parseDateInput = (displayDate) => {
                const parts = displayDate.split('.');
                if (parts.length === 3) {
                    const [day, month, year] = parts;
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }
                return null;
            };
            
            // Fetch min and max dates directly from the database
            try {
                const minDateUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=game_date&order=game_date.asc&limit=1`;
                const maxDateUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=game_date&order=game_date.desc&limit=1`;
                
                const [minResponse, maxResponse] = await Promise.all([
                    fetch(minDateUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    }),
                    fetch(maxDateUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    })
                ]);
                
                const minData = await minResponse.json();
                const maxData = await maxResponse.json();
                
                if (minData.length > 0 && maxData.length > 0) {
                    const minDate = minData[0].game_date.split('T')[0];
                    const maxDate = maxData[0].game_date.split('T')[0];
                    
                    console.log('Date range from DB:', minDate, 'to', maxDate);
                    
                    // Set default values in yyyy-MM-dd format for filtering
                    filterMinDate = minDate;
                    filterMaxDate = maxDate;
                    
                    // Display in dd.MM.yyyy format
                    minDateInput.value = formatDateDisplay(minDate);
                    maxDateInput.value = formatDateDisplay(maxDate);
                    
                    // Store the internal values as data attributes
                    minDateInput.dataset.isoDate = minDate;
                    maxDateInput.dataset.isoDate = maxDate;
                }
            } catch (error) {
                console.error('Error fetching date range:', error);
            }
            
            // Make inputs editable and handle click to show date picker
            minDateInput.removeAttribute('readonly');
            maxDateInput.removeAttribute('readonly');
            
            // Handle date changes for min date
            minDateInput.addEventListener('click', function() {
                const tempInput = document.createElement('input');
                tempInput.type = 'date';
                tempInput.value = this.dataset.isoDate || filterMinDate;
                tempInput.style.position = 'absolute';
                tempInput.style.opacity = '0';
                document.body.appendChild(tempInput);
                
                tempInput.addEventListener('change', () => {
                    if (tempInput.value) {
                        filterMinDate = tempInput.value;
                        minDateInput.value = formatDateDisplay(tempInput.value);
                        minDateInput.dataset.isoDate = tempInput.value;
                        applyFilters();
                    }
                    document.body.removeChild(tempInput);
                });
                
                tempInput.showPicker ? tempInput.showPicker() : tempInput.click();
            });
            
            // Handle date changes for max date
            maxDateInput.addEventListener('click', function() {
                const tempInput = document.createElement('input');
                tempInput.type = 'date';
                tempInput.value = this.dataset.isoDate || filterMaxDate;
                tempInput.style.position = 'absolute';
                tempInput.style.opacity = '0';
                document.body.appendChild(tempInput);
                
                tempInput.addEventListener('change', () => {
                    if (tempInput.value) {
                        filterMaxDate = tempInput.value;
                        maxDateInput.value = formatDateDisplay(tempInput.value);
                        maxDateInput.dataset.isoDate = tempInput.value;
                        applyFilters();
                    }
                    document.body.removeChild(tempInput);
                });
                
                tempInput.showPicker ? tempInput.showPicker() : tempInput.click();
            });
        }

        // Setup hidden players checkbox
        function setupHiddenPlayersFilter() {
            const checkbox = document.getElementById('showHiddenCheckbox');
            if (checkbox) {
                checkbox.addEventListener('change', () => {
                    showHiddenPlayers = checkbox.checked;
                    console.log('Show hidden players:', showHiddenPlayers);
                    applyFilters();
                });
            }
        }

        function setupActivePlayersFilter() {
            const checkbox = document.getElementById('onlyActiveCheckbox');
            if (checkbox) {
                checkbox.addEventListener('change', () => {
                    onlyActivePlayersFilter = checkbox.checked;
                    
                    // Calculate fromDate for logging
                    let fromDate = null;
                    if (lastGameDate && activityPeriodDays) {
                        const lastDate = new Date(lastGameDate);
                        const cutoffDate = new Date(lastDate);
                        cutoffDate.setDate(cutoffDate.getDate() - activityPeriodDays);
                        fromDate = cutoffDate.toISOString().split('T')[0];
                    }
                    
                    console.log('Only active players filter:', {
                        enabled: onlyActivePlayersFilter,
                        activityPeriodDays: activityPeriodDays,
                        lastGameDate: lastGameDate,
                        fromDate: fromDate
                    });
                    
                    applyFilters();
                });
            }
        }

        // Compare button handler
        document.getElementById('compareBtn').addEventListener('click', () => {
            comparisonMode = true;
            document.getElementById('secondarySearchContainer').classList.add('show');
            document.getElementById('closeCompareBtn').style.display = 'flex';
            document.getElementById('compareBtn').style.display = 'none';
            
            // Focus on second input
            setTimeout(() => {
                document.getElementById('playerSearchInput2').focus();
            }, 100);
        });

        // Close compare button handler
        document.getElementById('closeCompareBtn').addEventListener('click', () => {
            comparisonMode = false;
            selectedPlayer2 = null;
            document.getElementById('secondarySearchContainer').classList.remove('show');
            document.getElementById('closeCompareBtn').style.display = 'none';
            document.getElementById('compareBtn').style.display = 'block';
            document.getElementById('playerSearchInput2').value = '';
            closeAutocomplete2();
            
            // Reload single player view (already shown)
            if (selectedPlayer1) {
                showPlayerStats(selectedPlayer1);
            }
        });

        // Back button handler
        document.getElementById('backButton').addEventListener('click', showMainTableView);

        // ESC key to go back (when not in input field)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const playerStatsPage = document.getElementById('playerStatsPage');
                if (playerStatsPage.classList.contains('show') && 
                    document.activeElement !== playerSearchInput && 
                    document.activeElement !== playerSearchInput2) {
                    e.preventDefault();
                    showMainTableView();
                }
            }
        });

        // Calculate summary statistics from game data
        function calculatePlayerStats(games) {
            const stats = {
                M: { wins: 0, losses: 0 },
                Sh: { wins: 0, losses: 0 },
                Mf: { wins: 0, losses: 0 },
                D: { wins: 0, losses: 0 }
            };

            games.forEach(game => {
                const role = game.role_code;
                if (stats[role]) {
                    if (game.player_won) {
                        stats[role].wins++;
                    } else {
                        stats[role].losses++;
                    }
                }
            });

            // Calculate totals
            const redWins = stats.M.wins + stats.Sh.wins;
            const redLosses = stats.M.losses + stats.Sh.losses;
            const blackWins = stats.Mf.wins + stats.D.wins;
            const blackLosses = stats.Mf.losses + stats.D.losses;
            const totalWins = redWins + blackWins;
            const totalLosses = redLosses + blackLosses;
            const totalGames = totalWins + totalLosses;
            const winPct = totalGames > 0 ? (totalWins / totalGames * 100) : 0;

            return {
                byRole: stats,
                red: { wins: redWins, losses: redLosses },
                black: { wins: blackWins, losses: blackLosses },
                total: { wins: totalWins, losses: totalLosses, games: totalGames, winPct }
            };
        }

        // Fetch player game data from Supabase
        async function fetchPlayerGames(playerName) {
            try {
                const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?player_name=eq.${encodeURIComponent(playerName)}&order=game_id.desc`;
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`–ü–∞–º—ã–ª–∫–∞ –∑–∞–≥—Ä—É–∑–∫—ñ –¥–∞–¥–∑–µ–Ω—ã—Ö. –°—Ç–∞—Ç—É—Å: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching player games:', error);
                throw error;
            }
        }

        // Fetch all game participants for given game IDs
        async function fetchGameParticipants(gameIds) {
            try {
                if (!gameIds || gameIds.length === 0) {
                    return [];
                }

                // Build query with OR conditions for all game IDs
                const gameIdFilters = gameIds.map(id => `game_id.eq.${id}`).join(',');
                const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?or=(${gameIdFilters})`;
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`–ü–∞–º—ã–ª–∫–∞ –∑–∞–≥—Ä—É–∑–∫—ñ –¥–∞–¥–∑–µ–Ω—ã—Ö. –°—Ç–∞—Ç—É—Å: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching game participants:', error);
                throw error;
            }
        }

        // Calculate head-to-head statistics
        function calculateHeadToHeadStats(games1, games2) {
            // Find common games
            const player1GameMap = {};
            games1.forEach(game => {
                player1GameMap[game.game_id] = game;
            });

            const commonGames = [];
            games2.forEach(game => {
                if (player1GameMap[game.game_id]) {
                    commonGames.push({
                        player1: player1GameMap[game.game_id],
                        player2: game
                    });
                }
            });

            // Calculate stats for each combination
            const stats = {
                redRed: { wins: 0, losses: 0, roles: {} },      // Both red team
                redBlack: { wins: 0, losses: 0, roles: {} },    // P1 red, P2 black
                blackRed: { wins: 0, losses: 0, roles: {} },    // P1 black, P2 red
                blackBlack: { wins: 0, losses: 0, roles: {} }   // Both black team
            };

            commonGames.forEach(({ player1, player2 }) => {
                const p1IsRed = player1.role_code === 'M' || player1.role_code === 'Sh';
                const p2IsRed = player2.role_code === 'M' || player2.role_code === 'Sh';
                const redWon = !player1.mafia_won;
                
                // Normalize role codes (Mf -> Ma for consistency)
                const p1RoleNormalized = player1.role_code === 'Mf' ? 'Ma' : player1.role_code;
                const p2RoleNormalized = player2.role_code === 'Mf' ? 'Ma' : player2.role_code;
                
                // Create role combination key
                const roleKey = `${p1RoleNormalized}-${p2RoleNormalized}`;

                if (p1IsRed && p2IsRed) {
                    if (redWon) stats.redRed.wins++;
                    else stats.redRed.losses++;
                    // Track role-specific stats
                    if (!stats.redRed.roles[roleKey]) {
                        stats.redRed.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.redRed.roles[roleKey].wins++;
                    else stats.redRed.roles[roleKey].losses++;
                } else if (p1IsRed && !p2IsRed) {
                    if (redWon) stats.redBlack.wins++;
                    else stats.redBlack.losses++;
                    // Track role-specific stats
                    if (!stats.redBlack.roles[roleKey]) {
                        stats.redBlack.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.redBlack.roles[roleKey].wins++;
                    else stats.redBlack.roles[roleKey].losses++;
                } else if (!p1IsRed && p2IsRed) {
                    if (redWon) stats.blackRed.wins++;
                    else stats.blackRed.losses++;
                    // Track role-specific stats
                    if (!stats.blackRed.roles[roleKey]) {
                        stats.blackRed.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.blackRed.roles[roleKey].wins++;
                    else stats.blackRed.roles[roleKey].losses++;
                } else {
                    if (redWon) stats.blackBlack.losses++;
                    else stats.blackBlack.wins++;
                    // Track role-specific stats
                    if (!stats.blackBlack.roles[roleKey]) {
                        stats.blackBlack.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.blackBlack.roles[roleKey].losses++;
                    else stats.blackBlack.roles[roleKey].wins++;
                }
            });

            return stats;
        }

        // Calculate partner and opponent statistics
        function calculatePartnerOpponentStats(currentPlayerGames, allGameParticipants) {
            const currentPlayerName = currentPlayerGames[0]?.player_name;
            if (!currentPlayerName) return [];

            // Create a map of game_id -> current player's role info
            const currentPlayerGameMap = {};
            currentPlayerGames.forEach(game => {
                currentPlayerGameMap[game.game_id] = {
                    role_code: game.role_code,
                    player_won: game.player_won,
                    isRed: game.role_code === 'M' || game.role_code === 'Sh'
                };
            });

            // Group all participants by player name
            const playerStatsMap = {};
            
            allGameParticipants.forEach(participant => {
                // Skip the current player
                if (participant.player_name === currentPlayerName) return;
                
                const gameId = participant.game_id;
                const currentPlayerInfo = currentPlayerGameMap[gameId];
                
                // Skip if current player wasn't in this game
                if (!currentPlayerInfo) return;
                
                const playerName = participant.player_name;
                const participantIsRed = participant.role_code === 'M' || participant.role_code === 'Sh';
                
                // Initialize player stats if not exists
                if (!playerStatsMap[playerName]) {
                    playerStatsMap[playerName] = {
                        name: playerName,
                        together: { total: 0, wins: 0, losses: 0 },
                        against: { total: 0, wins: 0, losses: 0 },
                        total: { total: 0, wins: 0, losses: 0 }
                    };
                }
                
                const stats = playerStatsMap[playerName];
                const sameTeam = currentPlayerInfo.isRed === participantIsRed;
                const currentPlayerWon = currentPlayerInfo.player_won;
                
                // Update total stats
                stats.total.total++;
                if (currentPlayerWon) {
                    stats.total.wins++;
                } else {
                    stats.total.losses++;
                }
                
                // Update together/against stats
                if (sameTeam) {
                    stats.together.total++;
                    if (currentPlayerWon) {
                        stats.together.wins++;
                    } else {
                        stats.together.losses++;
                    }
                } else {
                    stats.against.total++;
                    if (currentPlayerWon) {
                        stats.against.wins++;
                    } else {
                        stats.against.losses++;
                    }
                }
            });

            // Convert to array and sort by total games descending
            const playerStatsArray = Object.values(playerStatsMap);
            playerStatsArray.sort((a, b) => b.total.total - a.total.total);
            
            return playerStatsArray;
        }

        // Helper function for Belarusian plural forms
        function getWinsForm(n) {
            const mod10 = n % 10;
            const mod100 = n % 100;
            
            if (mod100 >= 11 && mod100 <= 14) {
                return '–ø–µ—Ä–∞–º–æ–≥';
            }
            if (mod10 === 1) {
                return '–ø–µ—Ä–∞–º–æ–≥–∞';
            }
            if (mod10 >= 2 && mod10 <= 4) {
                return '–ø–µ—Ä–∞–º–æ–≥—ñ';
            }
            return '–ø–µ—Ä–∞–º–æ–≥';
        }

        function getGamesForm(m) {
            const mod10 = m % 10;
            const mod100 = m % 100;
            
            if (mod100 >= 11 && mod100 <= 14) {
                return '–≥—É–ª—å–Ω—è—Ö';
            }
            if (mod10 === 1) {
                return '–≥—É–ª—å–Ω—ñ';
            }
            return '–≥—É–ª—å–Ω—è—Ö';
        }

        // Get role display name
        function getRoleDisplayName(roleCode) {
            const roleNames = {
                'M': '–ú—ñ—Ä–Ω—ã –∂—ã—Ö–∞—Ä',
                'Sh': '–®—ç—Ä—ã—Ñ',
                'Ma': '–ú–∞—Ñ—ñ—è',
                'Mf': '–ú–∞—Ñ—ñ—è',
                'D': '–î–æ–Ω'
            };
            return roleNames[roleCode] || roleCode;
        }

        // Get role color class (for text color)
        function getRoleColorClass(roleCode) {
            // Red team roles
            if (roleCode === 'M' || roleCode === 'Sh') {
                return 'role-red';
            }
            // Black team roles
            if (roleCode === 'Ma' || roleCode === 'Mf' || roleCode === 'D') {
                return 'role-black';
            }
            return '';
        }

        // Render role detail rows
        function renderRoleDetailRows(roleStats, parentRowIndex, player1Name, player2Name) {
            // Define all possible role combinations based on parent row type
            let allCombinations = [];
            
            if (parentRowIndex === 0) { // red-red
                allCombinations = ['M-M', 'M-Sh', 'Sh-M'];
            } else if (parentRowIndex === 1) { // black-black
                allCombinations = ['Ma-Ma', 'Ma-D', 'D-Ma'];
            } else if (parentRowIndex === 2) { // red-black
                allCombinations = ['M-Ma', 'M-D', 'Sh-Ma', 'Sh-D'];
            } else if (parentRowIndex === 3) { // black-red
                allCombinations = ['Ma-M', 'Ma-Sh', 'D-M', 'D-Sh'];
            }

            let detailRows = '';
            allCombinations.forEach(roleKey => {
                const [p1Role, p2Role] = roleKey.split('-');
                const stats = roleStats && roleStats[roleKey] ? roleStats[roleKey] : { wins: 0, losses: 0 };
                const total = stats.wins + stats.losses;
                
                const p1RoleName = getRoleDisplayName(p1Role);
                const p2RoleName = getRoleDisplayName(p2Role);
                const p1ColorClass = getRoleColorClass(p1Role);
                const p2ColorClass = getRoleColorClass(p2Role);
                
                // Determine which color class to use based on the parent row
                let colorClass = 'stat-bar-red';
                if (parentRowIndex === 1) colorClass = 'stat-bar-black'; // both-black
                else if (parentRowIndex === 3) colorClass = 'stat-bar-black'; // p1-black-p2-red
                
                let tooltipText = '';
                if (total > 0) {
                    const winsForm = getWinsForm(stats.wins);
                    const gamesForm = getGamesForm(total);
                    const winPct = (stats.wins / total * 100).toFixed(1);
                    tooltipText = `${p1RoleName} | ${p2RoleName}: ${stats.wins} ${winsForm} —É ${total} ${gamesForm} (${winPct}%)`;
                } else {
                    tooltipText = `${p1RoleName} | ${p2RoleName}: 0 –≥—É–ª—å–Ω—è—û`;
                }
                
                detailRows += `
                    <tr class="detail-row" data-parent-row="${parentRowIndex}">
                        <td class="role-detail ${p1ColorClass}">${p1RoleName}</td>
                        <td class="role-detail ${p2ColorClass}">${p2RoleName}</td>
                        <td>${renderStatBar(stats.wins, stats.losses, colorClass, `${parentRowIndex}-${roleKey}`, {
                            rowType: 'role-detail',
                            player1: player1Name,
                            player2: player2Name,
                            customTooltip: tooltipText
                        })}</td>
                    </tr>
                `;
            });
            
            return detailRows;
        }

        // Render stat bar
        function renderStatBar(wins, losses, winColorClass, rowIndex, tooltipData, useGrey = false, customColors = null) {
            const total = wins + losses;
            if (total === 0) {
                return '<div class="stat-bar-container"><div class="stat-bar-segment" style="width: 100%; background: #95a5a6;">0</div></div>';
            }

            const winPercent = (wins / total * 100);
            const lossPercent = (losses / total * 100);
            
            // Use custom colors for specific summary rows, grey for default summary, or normal colors
            let finalWinColorClass, finalLossColorClass, winColor, lossColor;
            if (customColors) {
                finalWinColorClass = customColors.win;
                finalLossColorClass = customColors.loss;
                winColor = customColors.winColor || 'custom';
                lossColor = customColors.lossColor || 'custom';
            } else if (useGrey) {
                finalWinColorClass = 'stat-bar-grey';
                finalLossColorClass = 'stat-bar-grey';
                winColor = 'grey';
                lossColor = 'grey';
            } else {
                finalWinColorClass = winColorClass;
                finalLossColorClass = winColorClass === 'stat-bar-red' ? 'stat-bar-black' : 'stat-bar-red';
                winColor = winColorClass === 'stat-bar-red' ? 'red' : 'black';
                lossColor = finalLossColorClass === 'stat-bar-red' ? 'red' : 'black';
            }

            // Generate tooltip text
            let tooltipText = '';
            if (tooltipData) {
                // Check for custom tooltip first
                if (tooltipData.customTooltip) {
                    tooltipText = tooltipData.customTooltip;
                } else {
                    const { rowType, player1, player2 } = tooltipData;
                    const winsForm = getWinsForm(wins);
                    const gamesForm = getGamesForm(total);
                    const winPct = winPercent.toFixed(1);
                    const lossPct = lossPercent.toFixed(1);
                    
                    if (rowType === 'both-red') {
                        tooltipText = `–†–∞–∑–∞–º –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö: ${wins} ${winsForm} —É ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'p1-red-p2-black') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `${player1} –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö: ${wins} ${winsForm} (${winPct}%) vs ${player2} –∑–∞ —á–æ—Ä–Ω—ã—Ö: ${losses} ${lossesForm} (${lossPct}%) —É ${total} ${gamesForm}`;
                    } else if (rowType === 'p1-black-p2-red') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `${player1} –∑–∞ —á–æ—Ä–Ω—ã—Ö: ${wins} ${winsForm} (${winPct}%) vs ${player2} –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö: ${losses} ${lossesForm} (${lossPct}%) —É ${total} ${gamesForm}`;
                    } else if (rowType === 'both-black') {
                        tooltipText = `–†–∞–∑–∞–º –∑–∞ —á–æ—Ä–Ω—ã—Ö: ${wins} ${winsForm} —É ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'summary-same') {
                        tooltipText = `–ê–≥—É–ª–∞–º –∑–∞ –∞–¥–∑—ñ–Ω –∫–æ–ª–µ—Ä: ${wins} ${winsForm} —É ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'summary-diff') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `–ê–≥—É–ª–∞–º –∑–∞ —Ä–æ–∑–Ω—ã—è –∫–æ–ª–µ—Ä—ã: ${player1}: ${wins} ${winsForm} (${winPct}%) vs ${player2}: ${losses} ${lossesForm} (${lossPct}%) —É ${total} ${gamesForm}`;
                    }
                }
            }

            const titleAttr = tooltipText ? ` title="${tooltipText}"` : '';

            // Hide segments with 0 value
            let segments = '';
            let containerClass = 'stat-bar-container';
            
            if (wins > 0 && losses > 0) {
                // Add connector class for summary rows with custom colors
                if (customColors) {
                    containerClass += ' with-connector';
                }
                segments = `
                    <div class="stat-bar-segment ${finalWinColorClass}" style="width: ${winPercent}%;" data-color="${winColor}" data-row="${rowIndex}">${wins}</div>
                    <div class="stat-bar-segment ${finalLossColorClass}" style="width: ${lossPercent}%;" data-color="${lossColor}" data-row="${rowIndex}">${losses}</div>
                `;
            } else if (wins > 0) {
                segments = `<div class="stat-bar-segment ${finalWinColorClass}" style="width: 100%;" data-color="${winColor}" data-row="${rowIndex}">${wins}</div>`;
            } else if (losses > 0) {
                segments = `<div class="stat-bar-segment ${finalLossColorClass}" style="width: 100%;" data-color="${lossColor}" data-row="${rowIndex}">${losses}</div>`;
            }

            return `
                <div class="${containerClass}"${titleAttr}>
                    ${segments}
                </div>
            `;
        }

        // Render personal stats table
        function renderPersonalStatsTable(h2hStats, player1Name, player2Name) {
            // Calculate summary stats
            const sameColorWins = h2hStats.redRed.wins + h2hStats.blackBlack.wins;
            const sameColorLosses = h2hStats.redRed.losses + h2hStats.blackBlack.losses;
            const sameColorTotal = sameColorWins + sameColorLosses;
            
            const diffColorWins = h2hStats.redBlack.wins + h2hStats.blackRed.losses;
            const diffColorLosses = h2hStats.redBlack.losses + h2hStats.blackRed.wins;
            const diffColorTotal = diffColorWins + diffColorLosses;
            
            // Determine bar color for same color (red team wins if redRed has more wins)
            const sameColorBarClass = 'stat-bar-red';
            
            // For different colors, we need to determine which team won more
            // diffColorWins represents red team wins (redBlack.wins = P1 red won, blackRed.losses = P2 red won)
            const diffColorBarClass = 'stat-bar-red';
            
            const sameColorWinsForm = getWinsForm(sameColorWins);
            const sameColorGamesForm = getGamesForm(sameColorTotal);
            const sameColorPct = sameColorTotal > 0 ? (sameColorWins / sameColorTotal * 100).toFixed(1) : '0.0';
            const sameColorTooltip = sameColorTotal > 0 ? `–ê–≥—É–ª–∞–º –∑–∞ –∞–¥–∑—ñ–Ω –∫–æ–ª–µ—Ä: ${sameColorWins} ${sameColorWinsForm} —É ${sameColorTotal} ${sameColorGamesForm} (${sameColorPct}%)` : '';
            
            const diffColorWinsForm = getWinsForm(diffColorWins);
            const diffColorGamesForm = getGamesForm(diffColorTotal);
            const diffColorPct = diffColorTotal > 0 ? (diffColorWins / diffColorTotal * 100).toFixed(1) : '0.0';
            const diffColorTooltip = diffColorTotal > 0 ? `–ê–≥—É–ª–∞–º –∑–∞ —Ä–æ–∑–Ω—ã—è –∫–æ–ª–µ—Ä—ã: ${diffColorWins} ${diffColorWinsForm} —É ${diffColorTotal} ${diffColorGamesForm} (${diffColorPct}%)` : '';

            return `
                <table class="personal-stats-table" id="personalStatsTable">
                    <thead>
                        <tr>
                            <th>${player1Name}</th>
                            <th>${player2Name}</th>
                            <th>–°—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr data-row="0" class="expandable-row" data-expandable="true">
                            <td data-color="red"><span class="expansion-indicator">‚ñ∂</span> <span class="color-indicator color-red"></span></td>
                            <td data-color="red"><span class="color-indicator color-red"></span></td>
                            <td>${renderStatBar(h2hStats.redRed.wins, h2hStats.redRed.losses, 'stat-bar-red', 0, {
                                rowType: 'both-red',
                                player1: player1Name,
                                player2: player2Name
                            })}</td>
                        </tr>
                        ${renderRoleDetailRows(h2hStats.redRed.roles, 0, player1Name, player2Name)}
                        <tr data-row="1" class="expandable-row" data-expandable="true">
                            <td data-color="black"><span class="expansion-indicator">‚ñ∂</span> <span class="color-indicator color-black"></span></td>
                            <td data-color="black"><span class="color-indicator color-black"></span></td>
                            <td>${renderStatBar(h2hStats.blackBlack.wins, h2hStats.blackBlack.losses, 'stat-bar-black', 1, {
                                rowType: 'both-black',
                                player1: player1Name,
                                player2: player2Name
                            })}</td>
                        </tr>
                        ${renderRoleDetailRows(h2hStats.blackBlack.roles, 1, player1Name, player2Name)}
                        <tr class="summary-row" data-row="summary-same">
                            <td colspan="2">–ê–≥—É–ª–∞–º –∑–∞ –∞–¥–∑—ñ–Ω –∫–æ–ª–µ—Ä</td>
                            <td>${renderStatBar(sameColorWins, sameColorLosses, sameColorBarClass, 'summary-same', {
                                rowType: 'summary-same',
                                player1: player1Name,
                                player2: player2Name
                            }, false, {
                                win: 'stat-bar-gold',
                                loss: 'stat-bar-silver',
                                winColor: 'gold',
                                lossColor: 'silver'
                            })}</td>
                        </tr>
                        <tr data-row="2" class="expandable-row" data-expandable="true">
                            <td data-color="red"><span class="expansion-indicator">‚ñ∂</span> <span class="color-indicator color-red"></span></td>
                            <td data-color="black"><span class="color-indicator color-black"></span></td>
                            <td>${renderStatBar(h2hStats.redBlack.wins, h2hStats.redBlack.losses, 'stat-bar-red', 2, {
                                rowType: 'p1-red-p2-black',
                                player1: player1Name,
                                player2: player2Name
                            })}</td>
                        </tr>
                        ${renderRoleDetailRows(h2hStats.redBlack.roles, 2, player1Name, player2Name)}
                        <tr data-row="3" class="expandable-row" data-expandable="true">
                            <td data-color="black"><span class="expansion-indicator">‚ñ∂</span> <span class="color-indicator color-black"></span></td>
                            <td data-color="red"><span class="color-indicator color-red"></span></td>
                            <td>${renderStatBar(h2hStats.blackRed.losses, h2hStats.blackRed.wins, 'stat-bar-black', 3, {
                                rowType: 'p1-black-p2-red',
                                player1: player1Name,
                                player2: player2Name
                            })}</td>
                        </tr>
                        ${renderRoleDetailRows(h2hStats.blackRed.roles, 3, player1Name, player2Name)}
                        <tr class="summary-row" data-row="summary-diff">
                            <td colspan="2">–ê–≥—É–ª–∞–º –∑–∞ —Ä–æ–∑–Ω—ã—è –∫–æ–ª–µ—Ä—ã</td>
                            <td>${renderStatBar(diffColorWins, diffColorLosses, diffColorBarClass, 'summary-diff', {
                                rowType: 'summary-diff',
                                player1: player1Name,
                                player2: player2Name
                            }, false, {
                                win: 'stat-bar-green',
                                loss: 'stat-bar-blue',
                                winColor: 'green',
                                lossColor: 'blue'
                            })}</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Setup hover handlers for personal stats table
        function setupPersonalStatsHover() {
            const table = document.getElementById('personalStatsTable');
            if (!table) return;

            const segments = table.querySelectorAll('.stat-bar-segment');
            
            segments.forEach(segment => {
                segment.addEventListener('mouseenter', (e) => {
                    const color = e.target.dataset.color;
                    const rowIndex = e.target.dataset.row;
                    
                    // Highlight cells with matching color in the same row
                    const row = table.querySelector(`tr[data-row="${rowIndex}"]`);
                    if (row) {
                        const cells = row.querySelectorAll(`td[data-color="${color}"]`);
                        cells.forEach(cell => cell.classList.add('highlight'));
                    }
                });

                segment.addEventListener('mouseleave', (e) => {
                    // Remove all highlights
                    const highlightedCells = table.querySelectorAll('td.highlight');
                    highlightedCells.forEach(cell => cell.classList.remove('highlight'));
                });
            });
        }

        // Setup expansion handlers for personal stats table
        function setupPersonalStatsExpansion() {
            const table = document.getElementById('personalStatsTable');
            if (!table) return;

            const expandableRows = table.querySelectorAll('.expandable-row');
            
            expandableRows.forEach(row => {
                row.addEventListener('click', (e) => {
                    const rowIndex = row.dataset.row;
                    const detailRows = table.querySelectorAll(`.detail-row[data-parent-row="${rowIndex}"]`);
                    const indicator = row.querySelector('.expansion-indicator');
                    
                    if (!detailRows.length) return; // No detail rows to expand
                    
                    // Check if currently expanded
                    const isExpanded = detailRows[0].classList.contains('expanded');
                    
                    if (isExpanded) {
                        // Collapse
                        detailRows.forEach(detailRow => {
                            detailRow.classList.remove('expanded');
                        });
                        if (indicator) indicator.textContent = '‚ñ∂';
                        row.classList.remove('expanded');
                    } else {
                        // Expand current row (multiple rows can be expanded at once)
                        detailRows.forEach(detailRow => {
                            detailRow.classList.add('expanded');
                        });
                        if (indicator) indicator.textContent = '‚ñº';
                        row.classList.add('expanded');
                    }
                });
                
                // Add visual feedback on hover
                row.style.cursor = 'pointer';
            });
        }

        // Render summary stats table
        function renderSummaryTable(stats) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100).toFixed(1) : '0.0';
            };

            return `
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th style="text-align: center;">–†–æ–ª—è</th>
                            <th>–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th>–ü–∞—Ä–∞–∑—ã</th>
                            <th>–ì—É–ª—å–Ω—ñ</th>
                            <th>%</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>–ú—ñ—Ä–Ω—ã –∂—ã—Ö–∞—Ä</td>
                            <td class="win-cell">${stats.byRole.M.wins}</td>
                            <td class="loss-cell">${stats.byRole.M.losses}</td>
                            <td>${stats.byRole.M.wins + stats.byRole.M.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.M.wins, stats.byRole.M.losses)}%</td>
                        </tr>
                        <tr>
                            <td>–®—ç—Ä—ã—Ñ</td>
                            <td class="win-cell">${stats.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats.byRole.Sh.losses}</td>
                            <td>${stats.byRole.Sh.wins + stats.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.Sh.wins, stats.byRole.Sh.losses)}%</td>
                        </tr>
                        <tr class="team-row">
                            <td>–ê–≥—É–ª–∞–º –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö</td>
                            <td class="win-cell">${stats.red.wins}</td>
                            <td class="loss-cell">${stats.red.losses}</td>
                            <td>${stats.red.wins + stats.red.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.red.wins, stats.red.losses)}%</td>
                        </tr>
                        <tr>
                            <td>–ú–∞—Ñ—ñ—è</td>
                            <td class="win-cell">${stats.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats.byRole.Mf.losses}</td>
                            <td>${stats.byRole.Mf.wins + stats.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.Mf.wins, stats.byRole.Mf.losses)}%</td>
                        </tr>
                        <tr>
                            <td>–î–æ–Ω</td>
                            <td class="win-cell">${stats.byRole.D.wins}</td>
                            <td class="loss-cell">${stats.byRole.D.losses}</td>
                            <td>${stats.byRole.D.wins + stats.byRole.D.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.D.wins, stats.byRole.D.losses)}%</td>
                        </tr>
                        <tr class="team-row">
                            <td>–ê–≥—É–ª–∞–º –∑–∞ —á–æ—Ä–Ω—ã—Ö</td>
                            <td class="win-cell">${stats.black.wins}</td>
                            <td class="loss-cell">${stats.black.losses}</td>
                            <td>${stats.black.wins + stats.black.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.black.wins, stats.black.losses)}%</td>
                        </tr>
                        <tr class="total-row">
                            <td>–£—Å—è–≥–æ</td>
                            <td class="win-cell">${stats.total.wins}</td>
                            <td class="loss-cell">${stats.total.losses}</td>
                            <td>${stats.total.wins + stats.total.losses}</td>
                            <td class="percentage-cell">${stats.total.winPct.toFixed(1)}%</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Render partner and opponent stats table with pagination
        function renderPartnerOpponentTable(partnerStats, page = 1) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100).toFixed(1) : '0.0';
            };

            if (!partnerStats || partnerStats.length === 0) {
                return '<p>–ù—è–º–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö –¥–ª—è –∞–¥–ª—é—Å—Ç—Ä–∞–≤–∞–Ω–Ω—è</p>';
            }

            currentPartnerPage = page;

            // Calculate pagination
            const totalPages = Math.ceil(partnerStats.length / partnersPerPage);
            const startIdx = (page - 1) * partnersPerPage;
            const endIdx = startIdx + partnersPerPage;
            const paginatedPartners = partnerStats.slice(startIdx, endIdx);

            const rows = paginatedPartners.map(player => {
                return `
                    <tr>
                        <td class="partner-player-cell" style="text-align: left;" onclick="compareWithPlayer('${player.name.replace(/'/g, "\\'")}')">
                            <span class="partner-player-name">${player.name}</span>
                        </td>
                        <td class="win-cell">${player.together.wins}</td>
                        <td class="loss-cell">${player.together.losses}</td>
                        <td>${player.together.total}</td>
                        <td class="percentage-cell">${calcPct(player.together.wins, player.together.losses)}%</td>
                        <td class="win-cell">${player.against.wins}</td>
                        <td class="loss-cell">${player.against.losses}</td>
                        <td>${player.against.total}</td>
                        <td class="percentage-cell">${calcPct(player.against.wins, player.against.losses)}%</td>
                        <td class="win-cell">${player.total.wins}</td>
                        <td class="loss-cell">${player.total.losses}</td>
                        <td>${player.total.total}</td>
                        <td class="percentage-cell">${calcPct(player.total.wins, player.total.losses)}%</td>
                    </tr>
                `;
            }).join('');

            // Pagination controls
            const paginationHTML = partnerStats.length > partnersPerPage ? `
                <div class="pagination">
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(1)">¬´</button>
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(${page - 1})">‚Äπ</button>
                    <span class="pagination-info">–°—Ç–∞—Ä–æ–Ω–∫–∞ ${page} –∑ ${totalPages} (—É—Å—è–≥–æ –≥—É–ª—å—Ü–æ—û: ${partnerStats.length})</span>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${page + 1})">‚Ä∫</button>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${totalPages})">¬ª</button>
                </div>
            ` : '';

            return `
                <table class="stats-table" id="partnerOpponentTable">
                    <thead>
                        <tr>
                            <th rowspan="2" style="text-align: center;">–ì—É–ª–µ—Ü</th>
                            <th colspan="4">–†–∞–∑–∞–º</th>
                            <th colspan="4">–°—É–ø—Ä–∞—Ü—å</th>
                            <th colspan="4">–ê–≥—É–ª–∞–º</th>
                        </tr>
                        <tr>
                            <th class="sortable" data-column="togetherWins" title="–ü–µ—Ä–∞–º–æ–≥—ñ —Ä–∞–∑–∞–º" style="min-width: 80px;">–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th class="sortable" data-column="togetherLosses" title="–ü–∞—Ä–∞–∑—ã —Ä–∞–∑–∞–º" style="min-width: 80px;">–ü–∞—Ä–∞–∑—ã</th>
                            <th class="sortable" data-column="togetherTotal" title="–£—Å—è–≥–æ —Ä–∞–∑–∞–º" style="min-width: 80px;">–ì—É–ª—å–Ω—ñ</th>
                            <th class="sortable" data-column="togetherPct" title="–ü—Ä–∞—Ü—ç–Ω—Ç –ø–µ—Ä–∞–º–æ–≥ —Ä–∞–∑–∞–º" style="min-width: 60px;">%</th>
                            <th class="sortable" data-column="againstWins" title="–ü–µ—Ä–∞–º–æ–≥—ñ —Å—É–ø—Ä–∞—Ü—å" style="min-width: 80px;">–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th class="sortable" data-column="againstLosses" title="–ü–∞—Ä–∞–∑—ã —Å—É–ø—Ä–∞—Ü—å" style="min-width: 80px;">–ü–∞—Ä–∞–∑—ã</th>
                            <th class="sortable" data-column="againstTotal" title="–£—Å—è–≥–æ —Å—É–ø—Ä–∞—Ü—å" style="min-width: 80px;">–ì—É–ª—å–Ω—ñ</th>
                            <th class="sortable" data-column="againstPct" title="–ü—Ä–∞—Ü—ç–Ω—Ç –ø–µ—Ä–∞–º–æ–≥ —Å—É–ø—Ä–∞—Ü—å" style="min-width: 60px;">%</th>
                            <th class="sortable" data-column="totalWins" title="–£—Å—è–≥–æ –ø–µ—Ä–∞–º–æ–≥" style="min-width: 80px;">–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th class="sortable" data-column="totalLosses" title="–£—Å—è–≥–æ –ø–∞—Ä–∞–∑" style="min-width: 80px;">–ü–∞—Ä–∞–∑—ã</th>
                            <th class="sortable" data-column="totalTotal" title="–£—Å—è–≥–æ –≥—É–ª—å–Ω—è—û" style="min-width: 80px;">–ì—É–ª—å–Ω—ñ</th>
                            <th class="sortable" data-column="totalPct" title="–ê–≥—É–ª—å–Ω—ã –ø—Ä–∞—Ü—ç–Ω—Ç –ø–µ—Ä–∞–º–æ–≥" style="min-width: 60px;">%</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
                ${paginationHTML}
            `;
        }

        // Navigate to a specific partner page
        function goToPartnerPage(page) {
            const partnerSection = document.querySelector('.stats-section:has(#partnerOpponentTable)');
            if (partnerSection) {
                const newTableHTML = renderPartnerOpponentTable(partnerTableData, page);
                partnerSection.innerHTML = `<h3>–ü–∞—Ä—Ç–Ω—ë—Ä—ã —ñ —Å—É–ø–µ—Ä–Ω—ñ–∫—ñ</h3>${newTableHTML}`;
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            }
        }

        // Sort partner/opponent table
        function sortPartnerTable(column) {
            if (partnerTableSort.column === column) {
                partnerTableSort.ascending = !partnerTableSort.ascending;
            } else {
                partnerTableSort.column = column;
                partnerTableSort.ascending = false; // Default to descending
                currentPartnerPage = 1; // Reset to first page when changing sort column
            }

            // Sort the data
            partnerTableData.sort((a, b) => {
                let aVal, bVal;
                
                // Handle different column types
                if (column === 'together' || column === 'against' || column === 'total') {
                    // Sort by total for section headers
                    aVal = a[column].total;
                    bVal = b[column].total;
                } else if (column.endsWith('Pct')) {
                    // Sort by percentage
                    const section = column.replace('Pct', '');
                    const aTotal = a[section].wins + a[section].losses;
                    const bTotal = b[section].wins + b[section].losses;
                    aVal = aTotal > 0 ? (a[section].wins / aTotal) : 0;
                    bVal = bTotal > 0 ? (b[section].wins / bTotal) : 0;
                } else {
                    // Sort by specific stat (wins, losses, total)
                    const parts = column.match(/^(together|against|total)(.+)$/);
                    if (parts) {
                        const section = parts[1];
                        const stat = parts[2].toLowerCase();
                        aVal = a[section][stat];
                        bVal = b[section][stat];
                    }
                }

                if (aVal === bVal) return 0;
                const comparison = aVal > bVal ? 1 : -1;
                return partnerTableSort.ascending ? comparison : -comparison;
            });

            // Re-render the table with current page
            const tableContainer = document.querySelector('.stats-section:has(#partnerOpponentTable)');
            if (tableContainer) {
                const newTableHTML = renderPartnerOpponentTable(partnerTableData, currentPartnerPage);
                tableContainer.innerHTML = `<h3>–ü–∞—Ä—Ç–Ω—ë—Ä—ã —ñ —Å—É–ø–µ—Ä–Ω—ñ–∫—ñ</h3>${newTableHTML}`;
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            }
        }

        // Update sort indicators for partner table
        function updatePartnerTableSortIndicators() {
            const table = document.getElementById('partnerOpponentTable');
            if (!table) return;

            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            const sortedTh = table.querySelector(`th[data-column="${partnerTableSort.column}"]`);
            if (sortedTh) {
                sortedTh.classList.add(partnerTableSort.ascending ? 'sorted-asc' : 'sorted-desc');
            }
        }

        // Setup event listeners for partner table sorting
        function setupPartnerTableSorting() {
            const table = document.getElementById('partnerOpponentTable');
            if (!table) return;

            table.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.column;
                    sortPartnerTable(column);
                });
            });
        }

        // Compare current player with clicked player from partner table
        function compareWithPlayer(clickedPlayerName) {
            if (!selectedPlayer1) {
                console.error('No current player selected');
                return;
            }
            
            // Enter comparison mode
            comparisonMode = true;
            selectedPlayer2 = clickedPlayerName;
            
            // Update UI to show comparison mode
            document.getElementById('secondarySearchContainer').classList.add('show');
            document.getElementById('closeCompareBtn').style.display = 'flex';
            document.getElementById('compareBtn').style.display = 'none';
            document.getElementById('playerSearchInput2').value = clickedPlayerName;
            
            // Show comparison stats
            showComparisonStats(selectedPlayer1, selectedPlayer2);
        }

        // Render comparison stats table
        function renderComparisonTable(stats1, stats2, player1Name, player2Name) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100) : 0;
            };

            const addStar = (thisPct, otherPct, value) => {
                if (thisPct > otherPct && thisPct > 0) {
                    return `${value}% ‚≠ê`;
                }
                return `${value}%`;
            };

            // Calculate percentages for each row
            const mPct1 = calcPct(stats1.byRole.M.wins, stats1.byRole.M.losses);
            const mPct2 = calcPct(stats2.byRole.M.wins, stats2.byRole.M.losses);
            
            const shPct1 = calcPct(stats1.byRole.Sh.wins, stats1.byRole.Sh.losses);
            const shPct2 = calcPct(stats2.byRole.Sh.wins, stats2.byRole.Sh.losses);
            
            const redPct1 = calcPct(stats1.red.wins, stats1.red.losses);
            const redPct2 = calcPct(stats2.red.wins, stats2.red.losses);
            
            const mfPct1 = calcPct(stats1.byRole.Mf.wins, stats1.byRole.Mf.losses);
            const mfPct2 = calcPct(stats2.byRole.Mf.wins, stats2.byRole.Mf.losses);
            
            const dPct1 = calcPct(stats1.byRole.D.wins, stats1.byRole.D.losses);
            const dPct2 = calcPct(stats2.byRole.D.wins, stats2.byRole.D.losses);
            
            const blackPct1 = calcPct(stats1.black.wins, stats1.black.losses);
            const blackPct2 = calcPct(stats2.black.wins, stats2.black.losses);
            
            const totalPct1 = stats1.total.winPct;
            const totalPct2 = stats2.total.winPct;

            return `
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th rowspan="2" style="text-align: center;">–†–æ–ª—è</th>
                            <th colspan="4" class="player-column-header">${player1Name}</th>
                            <th colspan="4" class="player-column-header">${player2Name}</th>
                        </tr>
                        <tr>
                            <th style="text-align: center;">–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th>–ü–∞—Ä–∞–∑—ã</th>
                            <th>–ì—É–ª—å–Ω—ñ</th>
                            <th>%</th>
                            <th style="text-align: center;">–ü–µ—Ä–∞–º–æ–≥—ñ</th>
                            <th>–ü–∞—Ä–∞–∑—ã</th>
                            <th>–ì—É–ª—å–Ω—ñ</th>
                            <th>%</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>–ú—ñ—Ä–Ω—ã –∂—ã—Ö–∞—Ä</td>
                            <td class="win-cell">${stats1.byRole.M.wins}</td>
                            <td class="loss-cell">${stats1.byRole.M.losses}</td>
                            <td>${stats1.byRole.M.wins + stats1.byRole.M.losses}</td>
                            <td class="percentage-cell">${addStar(mPct1, mPct2, mPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.M.wins}</td>
                            <td class="loss-cell">${stats2.byRole.M.losses}</td>
                            <td>${stats2.byRole.M.wins + stats2.byRole.M.losses}</td>
                            <td class="percentage-cell">${addStar(mPct2, mPct1, mPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td>–®—ç—Ä—ã—Ñ</td>
                            <td class="win-cell">${stats1.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats1.byRole.Sh.losses}</td>
                            <td>${stats1.byRole.Sh.wins + stats1.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${addStar(shPct1, shPct2, shPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats2.byRole.Sh.losses}</td>
                            <td>${stats2.byRole.Sh.wins + stats2.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${addStar(shPct2, shPct1, shPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="team-row">
                            <td>–ê–≥—É–ª–∞–º –∑–∞ —á—ã—Ä–≤–æ–Ω—ã—Ö</td>
                            <td class="win-cell">${stats1.red.wins}</td>
                            <td class="loss-cell">${stats1.red.losses}</td>
                            <td>${stats1.red.wins + stats1.red.losses}</td>
                            <td class="percentage-cell">${addStar(redPct1, redPct2, redPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.red.wins}</td>
                            <td class="loss-cell">${stats2.red.losses}</td>
                            <td>${stats2.red.wins + stats2.red.losses}</td>
                            <td class="percentage-cell">${addStar(redPct2, redPct1, redPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td>–ú–∞—Ñ—ñ—è</td>
                            <td class="win-cell">${stats1.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats1.byRole.Mf.losses}</td>
                            <td>${stats1.byRole.Mf.wins + stats1.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${addStar(mfPct1, mfPct2, mfPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats2.byRole.Mf.losses}</td>
                            <td>${stats2.byRole.Mf.wins + stats2.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${addStar(mfPct2, mfPct1, mfPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td>–î–æ–Ω</td>
                            <td class="win-cell">${stats1.byRole.D.wins}</td>
                            <td class="loss-cell">${stats1.byRole.D.losses}</td>
                            <td>${stats1.byRole.D.wins + stats1.byRole.D.losses}</td>
                            <td class="percentage-cell">${addStar(dPct1, dPct2, dPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.D.wins}</td>
                            <td class="loss-cell">${stats2.byRole.D.losses}</td>
                            <td>${stats2.byRole.D.wins + stats2.byRole.D.losses}</td>
                            <td class="percentage-cell">${addStar(dPct2, dPct1, dPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="team-row">
                            <td>–ê–≥—É–ª–∞–º –∑–∞ —á–æ—Ä–Ω—ã—Ö</td>
                            <td class="win-cell">${stats1.black.wins}</td>
                            <td class="loss-cell">${stats1.black.losses}</td>
                            <td>${stats1.black.wins + stats1.black.losses}</td>
                            <td class="percentage-cell">${addStar(blackPct1, blackPct2, blackPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.black.wins}</td>
                            <td class="loss-cell">${stats2.black.losses}</td>
                            <td>${stats2.black.wins + stats2.black.losses}</td>
                            <td class="percentage-cell">${addStar(blackPct2, blackPct1, blackPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="total-row">
                            <td style="font-weight: bold;">–£—Å—è–≥–æ</td>
                            <td class="win-cell" style="font-weight: bold;">${stats1.total.wins}</td>
                            <td class="loss-cell" style="font-weight: bold;">${stats1.total.losses}</td>
                            <td style="font-weight: bold;">${stats1.total.wins + stats1.total.losses}</td>
                            <td class="percentage-cell" style="font-weight: bold;">${addStar(totalPct1, totalPct2, totalPct1.toFixed(1))}</td>
                            <td class="win-cell" style="font-weight: bold;">${stats2.total.wins}</td>
                            <td class="loss-cell" style="font-weight: bold;">${stats2.total.losses}</td>
                            <td style="font-weight: bold;">${stats2.total.wins + stats2.total.losses}</td>
                            <td class="percentage-cell" style="font-weight: bold;">${addStar(totalPct2, totalPct1, totalPct2.toFixed(1))}</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Pagination state
        let currentGamePage = 1;
        const gamesPerPage = 20;
        let allGames = [];

        // Partner table pagination state
        let currentPartnerPage = 1;
        const partnersPerPage = 20;

        // Render games list table with pagination
        function renderGamesTable(games, page = 1) {
            allGames = games;
            currentGamePage = page;
            
            const formatDate = (dateStr) => {
                if (!dateStr) return '‚Äî';
                const date = new Date(dateStr);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            };

            // Calculate pagination
            const totalPages = Math.ceil(games.length / gamesPerPage);
            const startIdx = (page - 1) * gamesPerPage;
            const endIdx = startIdx + gamesPerPage;
            const paginatedGames = games.slice(startIdx, endIdx);

            const rows = paginatedGames.map(game => {
                const gameNumber = game.game_number ? `#${game.game_number}` : `#${game.game_id}`;
                return `
                    <tr>
                        <td>${gameNumber}</td>
                        <td>${formatDate(game.game_date)}</td>
                        <td>${roleNames[game.role_code] || game.role_code}</td>
                        <td class="${game.player_won ? 'win-badge' : 'loss-badge'}">
                            ${game.player_won ? '–ü–µ—Ä–∞–º–æ–≥–∞' : '–ü–∞—Ä–∞–∑–∞'}
                        </td>
                    </tr>
                `;
            }).join('');

            // Pagination controls
            const paginationHTML = games.length > gamesPerPage ? `
                <div class="pagination">
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToGamePage(1)">¬´</button>
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToGamePage(${page - 1})">‚Äπ</button>
                    <span class="pagination-info">–°—Ç–∞—Ä–æ–Ω–∫–∞ ${page} –∑ ${totalPages} (—É—Å—è–≥–æ –≥—É–ª—å–Ω—è—û: ${games.length})</span>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToGamePage(${page + 1})">‚Ä∫</button>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToGamePage(${totalPages})">¬ª</button>
                </div>
            ` : '';

            return `
                <table class="games-table">
                    <thead>
                        <tr>
                            <th>–ì—É–ª—å–Ω—è</th>
                            <th>–î–∞—Ç–∞</th>
                            <th>–†–æ–ª—è</th>
                            <th>–í—ã–Ω—ñ–∫</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
                ${paginationHTML}
            `;
        }

        // Navigate to a specific game page
        function goToGamePage(page) {
            const gamesSection = document.querySelector('.stats-section:has(.games-table)');
            if (gamesSection) {
                const newTableHTML = renderGamesTable(allGames, page);
                gamesSection.innerHTML = `<h3>–ì—ñ—Å—Ç–æ—Ä—ã—è –≥—É–ª—å–Ω—è—û</h3>${newTableHTML}`;
            }
        }

        // Show player stats page
        async function showPlayerStats(playerName) {
            // Set player name in input field and update selected player
            document.getElementById('playerSearchInput').value = playerName;
            selectedPlayer1 = playerName;
            closeAutocomplete();
            
            // Update header title with player name
            document.getElementById('headerTitle').textContent = playerName;
            
            // Show player stats page with loading state
            const playerStatsBody = document.getElementById('playerStatsBody');
            playerStatsBody.innerHTML = `
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç—ã—Å—Ç—ã–∫—ñ...</p>
                </div>
            `;
            showPlayerStatsView();

            try {
                // Fetch player games
                const games = await fetchPlayerGames(playerName);

                if (!games || games.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>–ù—è–º–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö –¥–ª—è –≥—É–ª—å—Ü–∞</p>
                        </div>
                    `;
                    return;
                }

                // Calculate stats
                const stats = calculatePlayerStats(games);

                // Fetch all participants from the player's games for partner/opponent stats
                const gameIds = games.map(game => game.game_id);
                const allParticipants = await fetchGameParticipants(gameIds);
                const partnerStats = calculatePartnerOpponentStats(games, allParticipants);

                // Store partner data globally for sorting
                partnerTableData = partnerStats;
                partnerTableSort = { column: 'totalTotal', ascending: false };
                currentPartnerPage = 1;

                // Render player stats content
                playerStatsBody.innerHTML = `
                    <div class="stats-section">
                        <h3>–ê–≥—É–ª—å–Ω–∞—è —Å—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞</h3>
                        ${renderSummaryTable(stats)}
                    </div>
                    <div class="stats-section">
                        <h3>–ü–∞—Ä—Ç–Ω—ë—Ä—ã —ñ —Å—É–ø–µ—Ä–Ω—ñ–∫—ñ</h3>
                        ${renderPartnerOpponentTable(partnerStats, 1)}
                    </div>
                    <div class="stats-section">
                        <h3>–ì—ñ—Å—Ç–æ—Ä—ã—è –≥—É–ª—å–Ω—è—û</h3>
                        ${renderGamesTable(games)}
                    </div>
                `;

                // Setup sorting for partner table
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            } catch (error) {
                console.error('Error loading player stats:', error);
                playerStatsBody.innerHTML = `
                    <div class="player-stats-loading">
                        <p style="color: #c0392b;">–ü–∞–º—ã–ª–∫–∞ –∑–∞–≥—Ä—É–∑–∫—ñ: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Show comparison stats for two players
        async function showComparisonStats(player1Name, player2Name) {
            // Update header title with both player names
            document.getElementById('headerTitle').textContent = `${player1Name} vs ${player2Name}`;
            
            const playerStatsBody = document.getElementById('playerStatsBody');
            playerStatsBody.innerHTML = `
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>–ó–∞–≥—Ä—É–∑–∫–∞ –ø–∞—Ä–∞—û–Ω–∞–Ω–Ω—è...</p>
                </div>
            `;

            try {
                // Fetch both players' games
                const [games1, games2] = await Promise.all([
                    fetchPlayerGames(player1Name),
                    fetchPlayerGames(player2Name)
                ]);

                if (!games1 || games1.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>–ù—è–º–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö –¥–ª—è –≥—É–ª—å—Ü–∞ ${player1Name}</p>
                        </div>
                    `;
                    return;
                }

                if (!games2 || games2.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>–ù—è–º–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö –¥–ª—è –≥—É–ª—å—Ü–∞ ${player2Name}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate stats for both players
                const stats1 = calculatePlayerStats(games1);
                const stats2 = calculatePlayerStats(games2);

                // Calculate head-to-head stats
                const h2hStats = calculateHeadToHeadStats(games1, games2);

                // Render comparison content
                playerStatsBody.innerHTML = `
                    <div class="stats-section">
                        <h3>–ê–≥—É–ª—å–Ω–∞—è —Å—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞</h3>
                        ${renderComparisonTable(stats1, stats2, player1Name, player2Name)}
                    </div>
                    <div class="stats-section">
                        <h3>–ü–µ—Ä—Å–∞–Ω–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç—ã—Å—Ç—ã–∫–∞</h3>
                        ${renderPersonalStatsTable(h2hStats, player1Name, player2Name)}
                    </div>
                `;

                // Setup hover and expansion handlers after content is rendered
                setupPersonalStatsHover();
                setupPersonalStatsExpansion();
            } catch (error) {
                console.error('Error loading comparison stats:', error);
                playerStatsBody.innerHTML = `
                    <div class="player-stats-loading">
                        <p style="color: #c0392b;">–ü–∞–º—ã–ª–∫–∞ –∑–∞–≥—Ä—É–∑–∫—ñ: ${error.message}</p>
                    </div>
                `;
            }
        }

        async function loadData() {
            showStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö...', 'info');

            try {
                // First, fetch the minimum games threshold from settings
                try {
                    const settingsUrl = `${SUPABASE_URL}/rest/v1/app_settings?key=eq.min_games_threshold`;
                    const settingsResponse = await fetch(settingsUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (settingsResponse.ok) {
                        const settingsData = await settingsResponse.json();
                        if (settingsData && settingsData.length > 0) {
                            const thresholdValue = parseInt(settingsData[0].value);
                            if (!isNaN(thresholdValue)) {
                                defaultMinGamesThreshold = thresholdValue;
                                console.log('‚úÖ Loaded min games threshold from DB:', defaultMinGamesThreshold);
                            }
                        }
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not load threshold from DB, using default (25):', error);
                    // Keep default value of 25
                }
                
                // Fetch the activity period from settings
                try {
                    const activitySettingsUrl = `${SUPABASE_URL}/rest/v1/app_settings?key=eq.activity_period_days`;
                    const activitySettingsResponse = await fetch(activitySettingsUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (activitySettingsResponse.ok) {
                        const activitySettingsData = await activitySettingsResponse.json();
                        if (activitySettingsData && activitySettingsData.length > 0) {
                            const activityPeriodValue = parseInt(activitySettingsData[0].value);
                            if (!isNaN(activityPeriodValue)) {
                                activityPeriodDays = activityPeriodValue;
                                console.log('‚úÖ Loaded activity period from DB:', activityPeriodDays);
                            }
                        }
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Could not load activity period from DB, using default (30):', error);
                    // Keep default value of 30
                }
                
                // Fetch all data with pagination to ensure we get everything
                let allData = [];
                let pageSize = 1000;
                let currentPage = 0;
                let hasMore = true;
                
                while (hasMore) {
                    const rangeStart = currentPage * pageSize;
                    const rangeEnd = rangeStart + pageSize - 1;
                    
                    const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=*`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Range': `${rangeStart}-${rangeEnd}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`–ü–∞–º—ã–ª–∫–∞ –∑–∞–≥—Ä—É–∑–∫—ñ –¥–∞–¥–∑–µ–Ω—ã—Ö. –°—Ç–∞—Ç—É—Å: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (!data || data.length === 0) {
                        if (currentPage === 0) {
                            throw new Error('–ù—è–º–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö —É –±–∞–∑–µ. –ó–∞–ø—É—Å—Ü—ñ—Ü–µ import_games.py –¥–ª—è –∑–∞–≥—Ä—É–∑–∫—ñ –¥–∞–¥–∑–µ–Ω—ã—Ö.');
                        }
                        break;
                    }
                    
                    allData = allData.concat(data);
                    console.log(`Loaded page ${currentPage + 1}: ${data.length} games (total so far: ${allData.length})`);
                    
                    // If we got less than pageSize, we've reached the end
                    if (data.length < pageSize) {
                        hasMore = false;
                    } else {
                        currentPage++;
                    }
                }

                showStatus('–ê–ø—Ä–∞—Ü–æ—û–∫–∞ –¥–∞–¥–∑–µ–Ω—ã—Ö...', 'info');

                // Store all games data
                allGamesData = allData;
                console.log('‚úÖ Loaded', allGamesData.length, 'games total');

                // Calculate player stats from all games
                playerData = calculatePlayerDataFromGames(allGamesData);
                
                // Enrich with hidden status from player table
                playerData = await enrichPlayerDataWithHiddenStatus(playerData);
                filteredPlayerData = [...playerData];

                // Sort by total games descending by default
                currentSort = { column: 'total', ascending: true };
                sortData('total');

                // Hide status message and show filters and table
                document.getElementById('status').classList.remove('show');
                document.getElementById('filtersContainer').style.display = 'block';
                document.getElementById('tableWrapper').style.display = 'block';

                // Add click handlers to column headers
                document.querySelectorAll('th.sortable').forEach(th => {
                    th.addEventListener('click', () => {
                        const column = th.dataset.column;
                        sortData(column);
                    });
                });

                // Setup filter handlers
                setupFiltersToggle();
                setupPlayerFilter();
                setupGamesFilter();
                setupDateFilter();
                setupHiddenPlayersFilter();
                setupActivePlayersFilter();

            } catch (error) {
                console.error('–ü–∞–º—ã–ª–∫–∞:', error);
                showStatus('–ü–∞–º—ã–ª–∫–∞: ' + error.message, 'error');
            }
        }

        // Load data automatically when page loads
        window.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>
</html>
