<!DOCTYPE html>
<html lang="be">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Статыстыка Мафіі</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
            background: #f5f5f5;
            color: #2c2c2c;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            padding: 40px 30px;
            text-align: center;
            border-bottom: 1px solid #34495e;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            color: #ecf0f1;
            letter-spacing: 2px;
            font-weight: 400;
            text-transform: uppercase;
        }

        .header p {
            font-size: 1.1em;
            color: #bdc3c7;
            margin-top: 10px;
            font-weight: 300;
        }

        .back-button {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2em;
            cursor: pointer;
            padding: 10px;
            display: none;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .back-button.show {
            display: flex;
        }

        .header.player-view {
            text-align: left;
            padding-left: 100px;
        }

        .header.player-view h1 {
            font-size: 2em;
        }

        .header.player-view p {
            display: none;
        }

        .status {
            padding: 15px 30px;
            margin: 0;
            font-size: 14px;
            display: none;
            background: #e3f2fd;
            border-left: 3px solid #1976d2;
            color: #0d47a1;
        }

        .status.error {
            background: #ffebee;
            border-left-color: #c62828;
            color: #b71c1c;
        }

        .status.success {
            background: #e8f5e9;
            border-left-color: #388e3c;
            color: #1b5e20;
        }

        .status.show {
            display: block;
        }

        .filters-container {
            background: #f8f9fa;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 20px;
            margin: 20px;
        }

        .filters-title {
            font-size: 1.2em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .filters-content {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .filter-row {
            flex: 1;
            min-width: 200px;
            padding: 0 15px;
        }
        
        .filter-row:first-child {
            padding-left: 0;
        }
        
        .filter-row:last-child {
            padding-right: 0;
        }

        .filter-row:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            display: block;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 10px 0;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #d4af37;
        }

        .checkbox-label-text {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 500;
        }

        .player-filter-input-container {
            position: relative;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            background: #ffffff;
            padding: 8px;
            min-height: 42px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            cursor: text;
        }

        .player-filter-input-container:focus-within {
            border-color: #3498db;
            outline: 2px solid rgba(52, 152, 219, 0.2);
        }

        .player-tag {
            display: inline-flex;
            align-items: center;
            background: #3498db;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 13px;
            gap: 6px;
        }

        .player-tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            line-height: 1;
            transition: color 0.2s;
        }

        .player-tag-remove:hover {
            color: #ff6b6b;
        }

        .player-filter-input {
            border: none;
            outline: none;
            flex: 1;
            min-width: 120px;
            font-size: 14px;
            padding: 4px;
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
        }

        .player-filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 250px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            margin-top: 4px;
        }

        .player-filter-dropdown.show {
            display: block;
        }

        .player-filter-item {
            padding: 10px 12px;
            cursor: pointer;
            color: #2c3e50;
            font-size: 14px;
            border-bottom: 1px solid #f0f0f0;
        }

        .player-filter-item:last-child {
            border-bottom: none;
        }

        .player-filter-item:hover,
        .player-filter-item.selected {
            background: #e8eaf6;
        }

        .player-filter-item.disabled {
            color: #95a5a6;
            cursor: not-allowed;
            background: #f8f9fa;
        }

        .slider-container {
            padding: 10px 0;
        }

        .range-slider-wrapper {
            position: relative;
            padding: 10px 0 20px 0;
        }

        .range-slider-track {
            position: relative;
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
        }

        .range-slider-range {
            position: absolute;
            height: 100%;
            background: #3498db;
            border-radius: 3px;
        }

        .range-slider-inputs {
            position: relative;
            width: 100%;
        }

        .range-slider-input {
            position: absolute;
            width: 100%;
            pointer-events: none;
            appearance: none;
            -webkit-appearance: none;
            background: transparent;
            outline: none;
        }

        .range-slider-input::-webkit-slider-thumb {
            pointer-events: all;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #3498db;
            background: #ffffff;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .range-slider-input::-webkit-slider-thumb:hover {
            border-color: #2980b9;
            transform: scale(1.1);
        }

        .range-slider-input::-moz-range-thumb {
            pointer-events: all;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid #3498db;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .range-slider-input::-moz-range-thumb:hover {
            border-color: #2980b9;
            transform: scale(1.1);
        }

        .range-slider-values {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
            padding: 0 5px;
        }

        .range-slider-value {
            font-size: 16px;
            color: #2c3e50;
            font-weight: 600;
        }

        .filters-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .filters-toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: #7f8c8d;
        }

        .filters-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .filters-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .filters-content.expanded {
            max-height: 500px;
            margin-top: 15px;
        }

        .table-wrapper {
            position: relative;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        #dataTable {
            table-layout: fixed;
        }

        #dataTable th:first-child {
            width: 120px;
        }

        #dataTable th[data-column="mPlus"],
        #dataTable th[data-column="mMinus"],
        #dataTable th[data-column="shPlus"],
        #dataTable th[data-column="shMinus"],
        #dataTable th[data-column="mfPlus"],
        #dataTable th[data-column="mfMinus"],
        #dataTable th[data-column="dPlus"],
        #dataTable th[data-column="dMinus"],
        #dataTable th[data-column="redWins"],
        #dataTable th[data-column="redLosses"],
        #dataTable th[data-column="blackWins"],
        #dataTable th[data-column="blackLosses"],
        #dataTable th[data-column="totalWins"],
        #dataTable th[data-column="totalLosses"] {
            width: 55px;
        }

        #dataTable th[data-column="red"],
        #dataTable th[data-column="black"] {
            width: 55px;
        }

        #dataTable th[data-column="redPct"],
        #dataTable th[data-column="blackPct"],
        #dataTable th[data-column="winPct"] {
            width: 65px;
        }

        #dataTable th[data-column="total"] {
            width: 80px;
        }

        #dataTable td:first-child {
            width: 120px;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #ffffff;
        }

        th {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #34495e;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            white-space: nowrap;
            position: relative;
            font-family: 'Helvetica Neue', 'Arial', sans-serif;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        th:hover {
            background: #34495e;
            color: #ffffff;
        }

        th.sortable::after {
            content: ' ⇅';
            opacity: 0.4;
        }

        th.sorted-asc::after {
            content: ' ▲';
            opacity: 1;
            color: #ecf0f1;
        }

        th.sorted-desc::after {
            content: ' ▼';
            opacity: 1;
            color: #ecf0f1;
        }

        th:first-child {
            position: sticky;
            left: 0;
            z-index: 11;
            text-align: left;
            min-width: 150px;
        }

        td {
            padding: 12px 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            color: #2c2c2c;
            font-size: 14px;
        }

        td:first-child {
            position: sticky;
            left: 0;
            background: #f8f9fa;
            font-weight: 600;
            border-right: 1px solid #d0d0d0;
            z-index: 5;
            text-align: left;
            color: #2c3e50;
        }

        tbody tr:nth-child(odd) {
            background: #ffffff;
        }

        tbody tr:nth-child(even) {
            background: #fafafa;
        }

        tbody tr:nth-child(odd) td:first-child {
            background: #f8f9fa;
        }

        tbody tr:nth-child(even) td:first-child {
            background: #f0f1f2;
        }

        tbody tr:hover {
            background: #e8eaf6;
        }

        tbody tr:hover td:first-child {
            background: #dce1e9;
        }

        tbody tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        /* Clickable player cell in partner table */
        .partner-player-cell {
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .partner-player-cell:hover {
            background-color: #e3f2fd !important;
        }

        .partner-player-cell .partner-player-name {
            color: #3498db;
            transition: color 0.2s;
        }

        .partner-player-cell:hover .partner-player-name {
            color: #2980b9;
            text-decoration: underline;
        }

        /* Player Stats Page */
        .player-stats-page {
            display: none;
        }

        .player-stats-page.show {
            display: block;
        }

        .player-stats-header {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px 30px;
            border-bottom: 1px solid #34495e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-stats-header h2 {
            font-size: 1.8em;
            font-weight: 400;
            margin: 0;
            letter-spacing: 1px;
        }

        .player-search-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .player-search-container {
            position: relative;
        }

        .player-search-input {
            font-size: 1.5em;
            font-weight: 400;
            letter-spacing: 1px;
            padding: 8px 4px;
            border: none;
            border-bottom: 2px solid #ecf0f1;
            background: transparent;
            color: #ecf0f1;
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
            transition: border-color 0.3s;
            min-width: 230px;
        }

        .player-search-input::placeholder {
            color: rgba(236, 240, 241, 0.6);
        }

        .player-search-input:focus {
            outline: none;
            border-bottom-color: #3498db;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #34495e;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1005;
            display: none;
            margin-top: 4px;
        }

        .autocomplete-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .autocomplete-dropdown::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .autocomplete-dropdown::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .autocomplete-dropdown::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 12px 15px;
            cursor: pointer;
            color: #2c3e50;
            font-size: 1.1em;
            border-bottom: 1px solid #e0e0e0;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: #e8eaf6;
        }

        .autocomplete-item.no-results {
            cursor: default;
            color: #95a5a6;
            font-style: italic;
        }

        .autocomplete-item.no-results:hover {
            background: #ffffff;
        }

        .compare-btn {
            background: #3498db;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
        }

        .compare-btn:hover {
            background: #2980b9;
        }

        .compare-btn:active {
            transform: scale(0.95);
        }

        .player-search-container.secondary {
            display: none;
        }

        .player-search-container.secondary.show {
            display: block;
        }

        .close-compare-btn {
            background: #e74c3c;
            color: #ffffff;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
        }

        .close-compare-btn:hover {
            background: #c0392b;
            transform: rotate(90deg);
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
            table-layout: fixed;
        }

        .comparison-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
            width: 11%; /* 8 columns × 11% = 88% */
        }

        .comparison-table th:first-child {
            text-align: left;
            width: 12%; /* First column is smaller = 12% */
        }

        .comparison-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            width: 11%;
        }

        .comparison-table td:first-child {
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            width: 12%; /* First column is smaller = 12% */
        }

        .comparison-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .comparison-table tr:nth-child(even) {
            background: #ffffff;
        }

        .comparison-table .total-row {
            background: #e8eaf6 !important;
            font-weight: 600;
        }

        .comparison-table .team-row {
            background: #f0f1f2 !important;
            font-weight: 600;
            font-style: italic;
        }

        .player-column-header {
            background: #2c3e50 !important;
            color: #3498db !important;
            font-size: 1.1em;
        }

        .player1-header {
            color: #27ae60 !important;
        }

        .player2-header {
            color: #3498db !important;
        }

        .stat-bar-gold {
            background-color: #f39c12;
        }

        .stat-bar-silver {
            background-color: #95a5a6;
        }

        .stat-bar-green {
            background-color: #27ae60;
        }

        .stat-bar-blue {
            background-color: #3498db;
        }

        .personal-stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .personal-stats-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
            width: 20%;
        }

        .personal-stats-table th:last-child {
            width: 60%;
        }

        .personal-stats-table th:first-child {
            color: #27ae60;
        }

        .personal-stats-table th:nth-child(2) {
            color: #3498db;
            font-weight: bold;
        }

        .personal-stats-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
            background: inherit;
        }

        .personal-stats-table td:nth-child(1),
        .personal-stats-table td:nth-child(2) {
            width: 20%;
        }

        .personal-stats-table td:nth-child(3) {
            width: 60%;
        }

        .personal-stats-table tbody tr:nth-child(odd) td {
            background: #f8f9fa;
        }

        .personal-stats-table tbody tr:nth-child(even) td {
            background: #ffffff;
        }

        .personal-stats-table .summary-row td {
            font-weight: 600;
            background: #e8eaf6 !important;
        }

        .personal-stats-table .summary-row td[colspan] {
            text-align: center;
        }

        .stat-bar-grey {
            background-color: #95a5a6;
        }

        .stat-bar-grey:first-child,
        .stat-bar-gold:first-child,
        .stat-bar-green:first-child {
            margin-right: 8px;
            border-radius: 4px;
        }

        .stat-bar-grey:last-child,
        .stat-bar-silver:last-child,
        .stat-bar-blue:last-child {
            margin-left: 8px;
            border-radius: 4px;
        }

        .stat-bar-grey:only-child,
        .stat-bar-gold:only-child,
        .stat-bar-silver:only-child,
        .stat-bar-green:only-child,
        .stat-bar-blue:only-child {
            margin: 0;
            border-radius: 4px;
        }

        .personal-stats-table tbody tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .personal-stats-table tbody tr:nth-child(even) {
            background: #ffffff;
        }

        .personal-stats-table tbody tr:hover {
            background: inherit;
        }

        .personal-stats-table td.highlight {
            background-color: #e8eaf6 !important;
            transition: background-color 0.2s;
        }

        .personal-stats-table .expandable-row {
            cursor: pointer;
        }

        .personal-stats-table .expandable-row:hover td {
            background-color: #e3f2fd !important;
        }

        .personal-stats-table .detail-row {
            display: none;
            background-color: #f5f5f5 !important;
        }

        .personal-stats-table .detail-row.expanded {
            display: table-row;
        }

        .personal-stats-table .detail-row td {
            font-size: 13px;
            color: #555;
        }

        .personal-stats-table .detail-row td.role-detail {
            padding-left: 30px;
        }

        .personal-stats-table .detail-row td:nth-child(2) {
            font-weight: bold;
        }

        .personal-stats-table .detail-row td:nth-child(3) {
            padding: 10px;
        }

        .role-red {
            color: #e74c3c !important;
            font-weight: 600;
        }

        .role-black {
            color: #2c3e50 !important;
            font-weight: 600;
        }

        .expansion-indicator {
            display: inline-block;
            font-size: 10px;
            margin-right: 5px;
            transition: transform 0.2s;
            color: #666;
        }

        .personal-stats-table .expandable-row.expanded .expansion-indicator {
            transform: rotate(0deg);
        }

        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            vertical-align: middle;
            margin-right: 4px;
        }

        .color-red {
            background-color: #e74c3c;
        }

        .color-black {
            background-color: #000000;
        }

        .stat-bar-container {
            width: 100%;
            height: 30px;
            display: flex;
            border-radius: 4px;
                    overflow: hidden;
                    border: 1px solid #bdc3c7;
            position: relative;
            background: transparent;
        }

        .stat-bar-container.with-connector {
            overflow: visible;
            border: none;
        }

        .stat-bar-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            position: relative;
            z-index: 1;
        }

        .stat-bar-red {
            background-color: #e74c3c;
        }

        .stat-bar-black {
            background-color: #2c3e50;
        }

        .stat-bar-segment {
            cursor: pointer;
        }

        .stat-bar-segment:hover {
            opacity: 0.85;
        }

        .tables-container {
            display: block;
        }

        .table-section {
            width: 100%;
            margin-bottom: 30px;
        }

        .player-stats-body {
            padding: 30px;
        }

        .stats-section {
            margin-bottom: 40px;
        }

        .stats-section h3 {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid #2c3e50;
            padding-bottom: 8px;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .stats-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
        }

        .stats-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: center;
        }

        .stats-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .stats-table tr:nth-child(even) {
            background: #ffffff;
        }

        .stats-table td:first-child {
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
        }

        .stats-table .total-row {
            background: #e8eaf6 !important;
            font-weight: 600;
        }

        .stats-table .team-row {
            background: #f0f1f2 !important;
            font-weight: 600;
            font-style: italic;
        }

        .player-stats-loading {
            text-align: center;
            padding: 50px;
            color: #34495e;
        }

        .games-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }

        .games-table th {
            background: #34495e;
            color: #ecf0f1;
            padding: 12px 10px;
            text-align: left;
            font-weight: 500;
            border: 1px solid #2c3e50;
            font-size: 13px;
        }

        .games-table th:first-child {
            width: 80px;
            text-align: center;
        }

        .games-table td {
            padding: 10px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }

        .games-table td:first-child {
            text-align: center;
            font-weight: 600;
            color: #7f8c8d;
        }

        .games-table tr:nth-child(odd) {
            background: #f8f9fa;
        }

        .games-table tr:nth-child(even) {
            background: #ffffff;
        }

        .games-table tr:hover {
            background: #e8eaf6;
        }

        .win-badge {
            color: #27ae60;
            font-weight: 600;
        }

        .loss-badge {
            color: #c0392b;
            font-weight: 600;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            flex-wrap: wrap;
        }

        .pagination-btn {
            background: #2c3e50;
            color: #ecf0f1;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #34495e;
        }

        .pagination-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .pagination-info {
            color: #2c3e50;
            font-weight: 600;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #34495e;
        }

        .spinner {
            border: 4px solid #ecf0f1;
            border-top: 4px solid #34495e;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .win-cell {
            color: #27ae60;
            font-weight: 500;
        }

        .loss-cell {
            color: #c0392b;
        }

        .percentage-cell {
            color: #2c3e50;
            font-weight: 600;
            font-size: 1.05em;
        }

        .total-separator {
            border-left: 2px solid #e0e0e0 !important;
        }

        .table-controls {
            display: none;
            padding: 12px 20px;
            background: linear-gradient(to bottom, #f8f9fa 0%, #ecf0f1 100%);
            border-bottom: 1px solid #d0d0d0;
            text-align: right;
        }

        .columns-toggle-btn {
            background: none;
            border: none;
            color: #34495e;
            font-size: 13px;
            cursor: pointer;
            font-family: 'Baskerville', 'Garamond', 'Times New Roman', serif;
            padding: 8px 12px;
            transition: all 0.2s;
            text-decoration: underline;
            text-underline-offset: 3px;
            text-decoration-color: #bdc3c7;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .columns-toggle-btn:hover {
            color: #2c3e50;
            text-decoration-color: #34495e;
        }

        .columns-toggle-btn:active {
            transform: scale(0.98);
        }

        .columns-toggle-btn::before {
            content: '⚙';
            font-size: 15px;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .table-controls {
                display: block;
            }
            .header h1 {
                font-size: 2em;
            }

            .header::before,
            .header::after {
                display: none;
            }

            .header.player-view {
                padding-left: 70px;
            }

            .header.player-view h1 {
                font-size: 1.5em;
            }

            .back-button {
                left: 15px;
                font-size: 1.5em;
                width: 40px;
                height: 40px;
            }

            th, td {
                font-size: 12px;
                padding: 8px 5px;
            }

            /* Hide columns except: name, red%, black%, total, win% */
            #dataTable th:not(:nth-child(1)):not(:nth-child(9)):not(:nth-child(17)):not(:nth-child(20)):not(:nth-child(21)),
            #dataTable td:not(:nth-child(1)):not(:nth-child(9)):not(:nth-child(17)):not(:nth-child(20)):not(:nth-child(21)) {
                display: none;
            }

            /* Make visible columns more compact */
            #dataTable th:nth-child(1),
            #dataTable th:nth-child(9),
            #dataTable th:nth-child(17),
            #dataTable th:nth-child(20),
            #dataTable th:nth-child(21),
            #dataTable td:nth-child(1),
            #dataTable td:nth-child(9),
            #dataTable td:nth-child(17),
            #dataTable td:nth-child(20),
            #dataTable td:nth-child(21) {
                font-size: 11px;
                padding: 8px 3px;
            }

            /* Replace "Усяго" with Σ on mobile */
            #dataTable th:nth-child(20) {
                font-size: 0;
            }

            #dataTable th:nth-child(20)::after {
                content: 'Σ ⇅';
                font-size: 12px;
                font-weight: bold;
            }

            #dataTable th:nth-child(20).sortable::after {
                opacity: 0.4;
            }

            #dataTable th:nth-child(20).sorted-asc::after {
                content: 'Σ ▲';
                font-size: 12px;
                font-weight: bold;
                opacity: 1;
                color: #ecf0f1;
            }

            #dataTable th:nth-child(20).sorted-desc::after {
                content: 'Σ ▼';
                font-size: 12px;
                font-weight: bold;
                opacity: 1;
                color: #ecf0f1;
            }

            /* Make player name column a bit wider, compress percentage columns */
            #dataTable th:nth-child(1),
            #dataTable td:nth-child(1) {
                max-width: none;
                min-width: 80px;
            }

            #dataTable th:nth-child(9),
            #dataTable th:nth-child(17),
            #dataTable th:nth-child(21),
            #dataTable td:nth-child(9),
            #dataTable td:nth-child(17),
            #dataTable td:nth-child(21) {
                white-space: nowrap;
            }

            /* Show all columns when expanded */
            .table-wrapper.show-all-columns #dataTable th,
            .table-wrapper.show-all-columns #dataTable td {
                display: table-cell !important;
            }

            /* Make table fit content width on mobile */
            #dataTable {
                width: 100%;
                table-layout: auto;
            }

            /* Restore normal styles when expanded */
            .table-wrapper.show-all-columns #dataTable th:nth-child(20) {
                font-size: 12px;
            }

            .table-wrapper.show-all-columns #dataTable th:nth-child(20)::after {
                content: none;
            }

            .table-wrapper.show-all-columns #dataTable {
                table-layout: auto;
            }

            .player-search-wrapper {
                flex-wrap: wrap;
                gap: 10px;
            }

            .player-search-input {
                font-size: 1.2em;
                min-width: 180px;
            }

            .compare-btn {
                font-size: 0.8em;
                padding: 6px 12px;
            }

            .player-stats-header {
                padding: 15px 20px;
            }

            .comparison-table {
                table-layout: auto !important;
                width: 100% !important;
            }

            .comparison-table th,
            .comparison-table td {
                padding: 5px 2px !important;
                font-size: 9px !important;
            }

            /* First column - role names */
            .comparison-table th:first-child,
            .comparison-table td:first-child {
                width: 35px !important;
                max-width: 35px !important;
                min-width: 35px !important;
                font-size: 7px !important;
                padding: 2px 1px !important;
                word-break: break-word;
                line-height: 1;
                overflow: hidden;
                text-overflow: clip;
            }

            /* Data columns: +, -, Σ - all same width */
            .comparison-table th:nth-child(2),
            .comparison-table td:nth-child(2),
            .comparison-table th:nth-child(3),
            .comparison-table td:nth-child(3),
            .comparison-table th:nth-child(4),
            .comparison-table td:nth-child(4),
            .comparison-table th:nth-child(6),
            .comparison-table td:nth-child(6),
            .comparison-table th:nth-child(7),
            .comparison-table td:nth-child(7),
            .comparison-table th:nth-child(8),
            .comparison-table td:nth-child(8) {
                width: 32px !important;
                max-width: 32px !important;
                min-width: 32px !important;
            }

            /* Percentage columns - twice as wide */
            .comparison-table th:nth-child(5),
            .comparison-table td:nth-child(5),
            .comparison-table th:nth-child(9),
            .comparison-table td:nth-child(9) {
                width: 40px !important;
                max-width: 40px !important;
                min-width: 40px !important;
            }

            .personal-stats-table th,
            .personal-stats-table td {
                font-size: 12px;
                padding: 8px 4px;
            }

            .stat-bar-segment {
                font-size: 11px;
            }

            .pagination {
                gap: 5px;
                padding: 15px 10px;
            }

            .pagination-btn {
                padding: 6px 12px;
                font-size: 12px;
            }

            .pagination-info {
                font-size: 12px;
                width: 100%;
                text-align: center;
            }

            /* Mobile optimizations for stats-table (Агульная статыстыка) */
            .stats-table th:nth-child(2) {
                font-size: 0;
            }

            .stats-table th:nth-child(2)::after {
                content: '+';
                font-size: 13px;
                font-weight: bold;
            }

            .stats-table th:nth-child(3) {
                font-size: 0;
            }

            .stats-table th:nth-child(3)::after {
                content: '−';
                font-size: 13px;
                font-weight: bold;
            }

            .stats-table th:nth-child(4) {
                font-size: 0;
            }

            .stats-table th:nth-child(4)::after {
                content: 'Σ';
                font-size: 13px;
                font-weight: bold;
            }

            /* Mobile optimizations for partner/opponent table - shorten column headers */
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(1),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(5),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(9) {
                font-size: 0;
            }

            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(1)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(5)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(9)::after {
                content: '+';
                font-size: 12px;
                font-weight: bold;
            }

            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(2),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(6),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(10) {
                font-size: 0;
            }

            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(2)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(6)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(10)::after {
                content: '−';
                font-size: 12px;
                font-weight: bold;
            }

            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(3),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(7),
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(11) {
                font-size: 0;
            }

            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(3)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(7)::after,
            #partnerOpponentTable thead tr:nth-child(2) th:nth-child(11)::after {
                content: 'Σ';
                font-size: 12px;
                font-weight: bold;
            }

            /* Mobile optimizations for games-table (Гісторыя гульняў) */
            .games-table {
                table-layout: fixed;
            }

            .games-table th:nth-child(1),
            .games-table td:nth-child(1) {
                width: 45px !important;
                max-width: 45px !important;
                min-width: 45px !important;
                padding: 8px 2px !important;
            }

            .games-table th:nth-child(1) {
                font-size: 0 !important;
            }

            .games-table th:nth-child(1)::after {
                content: '#';
                font-size: 11px;
                font-weight: bold;
            }

            /* Mobile: make all headers in games-table smaller, centered, and allow wrapping */
            .games-table th {
                font-size: 10px !important;
                text-align: center !important;
                white-space: normal !important;
            }

            /* Mobile: center all cells in games-table */
            .games-table td {
                text-align: center !important;
            }

            /* Mobile: change "Перамога" column header to "+" in comparison mode */
            .games-table th:nth-child(5) {
                font-size: 0 !important;
            }

            .games-table th:nth-child(5)::after {
                content: '+';
                font-size: 11px;
                font-weight: bold;
            }

            /* Mobile: make last column (victory) narrower */
            .games-table th:nth-child(5),
            .games-table td:nth-child(5) {
                width: 32px !important;
                max-width: 32px !important;
                min-width: 32px !important;
                padding: 5px 2px !important;
            }

            /* Mobile optimizations for partner table - stable column widths */
            #partnerOpponentTable {
                table-layout: fixed;
                width: 100%;
            }

            #partnerOpponentTable th:nth-child(1),
            #partnerOpponentTable td:nth-child(1) {
                width: 35%;
            }

            #partnerOpponentTable th:nth-child(2),
            #partnerOpponentTable td:nth-child(2) {
                width: 15%;
            }

            #partnerOpponentTable th:nth-child(3),
            #partnerOpponentTable td:nth-child(3) {
                width: 15%;
            }

            #partnerOpponentTable th:nth-child(4),
            #partnerOpponentTable td:nth-child(4) {
                width: 15%;
            }

            #partnerOpponentTable th:nth-child(5),
            #partnerOpponentTable td:nth-child(5) {
                width: 20%;
            }

            /* Mobile optimizations for comparison table - shorten column headers */
            /* Second row has no first column due to rowspan, so indices are: 1=wins1, 2=losses1, 3=games1, 4=%1, 5=wins2, 6=losses2, 7=games2, 8=%2 */
            .comparison-table thead tr:nth-child(2) th:nth-child(1),
            .comparison-table thead tr:nth-child(2) th:nth-child(5) {
                font-size: 0 !important;
            }

            .comparison-table thead tr:nth-child(2) th:nth-child(1)::after,
            .comparison-table thead tr:nth-child(2) th:nth-child(5)::after {
                content: '+';
                font-size: 11px;
                font-weight: bold;
            }

            .comparison-table thead tr:nth-child(2) th:nth-child(2),
            .comparison-table thead tr:nth-child(2) th:nth-child(6) {
                font-size: 0 !important;
            }

            .comparison-table thead tr:nth-child(2) th:nth-child(2)::after,
            .comparison-table thead tr:nth-child(2) th:nth-child(6)::after {
                content: '−';
                font-size: 11px;
                font-weight: bold;
            }

            .comparison-table thead tr:nth-child(2) th:nth-child(3),
            .comparison-table thead tr:nth-child(2) th:nth-child(7) {
                font-size: 0 !important;
            }

            .comparison-table thead tr:nth-child(2) th:nth-child(3)::after,
            .comparison-table thead tr:nth-child(2) th:nth-child(7)::after {
                content: 'Σ';
                font-size: 11px;
                font-weight: bold;
            }

            /* Mobile optimizations for personal stats table - wrapper provides horizontal scrolling */
            .personal-stats-wrapper {
                margin-bottom: 20px;
            }

            .personal-stats-table {
                min-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" id="header">
            <button class="back-button" id="backButton">←</button>
            <h1 id="headerTitle">МАФІЯ</h1>
            <p id="headerSubtitle">Статыстыка гульцоў</p>
        </div>

        <div class="status" id="status"></div>

        <!-- Filters Section -->
        <div class="filters-container" id="filtersContainer" style="display: none;">
            <div class="filters-toggle" id="filtersToggle">
                <div class="filters-title">Фільтры</div>
                <span class="filters-toggle-icon" id="filtersToggleIcon">▼</span>
            </div>
            
            <div class="filters-content" id="filtersContent">
                <div class="filter-row">
                <label class="filter-label">Гульцы:</label>
                <div class="player-filter-input-container" id="playerFilterContainer">
                    <input 
                        type="text" 
                        id="playerFilterInput" 
                        class="player-filter-input" 
                        placeholder="Пачніце пісаць імя гульца..."
                        autocomplete="off"
                    />
                    <div class="player-filter-dropdown" id="playerFilterDropdown"></div>
                </div>
            </div>

            <div class="filter-row">
                <label class="filter-label">Колькасць гульняў:</label>
                <div class="slider-container">
                    <div class="range-slider-wrapper">
                        <div class="range-slider-track">
                            <div class="range-slider-range" id="sliderRange"></div>
                        </div>
                        <div class="range-slider-inputs">
                            <input 
                                type="range" 
                                id="minGamesSlider" 
                                class="range-slider-input"
                                min="0" 
                                max="100" 
                                value="0"
                                step="1"
                            />
                            <input 
                                type="range" 
                                id="maxGamesSlider" 
                                class="range-slider-input"
                                min="0" 
                                max="100" 
                                value="100"
                                step="1"
                            />
                        </div>
                        <div class="range-slider-values">
                            <div>
                                <div class="range-slider-value" id="minGamesDisplay">0</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="range-slider-value" id="maxGamesDisplay">100</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="filter-row">
                <label class="filter-label">Дата гульняў:</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input 
                        type="text" 
                        id="minDateFilter" 
                        class="player-filter-input" 
                        placeholder="дд.мм.гггг"
                        style="width: 110px; padding: 8px; cursor: pointer;"
                        readonly
                    />
                    <span style="color: #7f8c8d;">—</span>
                    <input 
                        type="text" 
                        id="maxDateFilter" 
                        class="player-filter-input" 
                        placeholder="дд.мм.гггг"
                        style="width: 110px; padding: 8px; cursor: pointer;"
                        readonly
                    />
                </div>
            </div>

            <div class="filter-row">
                <label class="checkbox-container">
                    <input type="checkbox" id="onlyActiveCheckbox" checked />
                    <span class="checkbox-label-text">Толькі актыўныя</span>
                </label>
            </div>
            </div>
        </div>

        <div class="table-controls" id="tableControls" style="display: none;">
            <button class="columns-toggle-btn" id="columnsToggleBtn">
                <span id="columnsToggleText">Паказаць усе калонкі</span>
            </button>
        </div>

        <div class="table-wrapper" id="tableWrapper" style="display: none;">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th class="sortable" data-column="name" title="Гулец">Гулец</th>
                        <th class="sortable" data-column="mPlus" title="Перамогі за мірных">М+</th>
                        <th class="sortable" data-column="mMinus" title="Паразы за мірных">М-</th>
                        <th class="sortable" data-column="shPlus" title="Перамогі за шэрыфа">Ш+</th>
                        <th class="sortable" data-column="shMinus" title="Паразы за шэрыфа">Ш-</th>
                        <th class="sortable" data-column="redWins" title="Перамогі за чырвоных"><span class="color-indicator color-red"></span>+</th>
                        <th class="sortable" data-column="redLosses" title="Паразы за чырвоных"><span class="color-indicator color-red"></span>-</th>
                        <th class="sortable" data-column="red" title="Агулам за чырвоных"><span class="color-indicator color-red"></span></th>
                        <th class="sortable" data-column="redPct" title="Адсотак перамог за чырвоных"><span class="color-indicator color-red"></span> %</th>
                        <th class="sortable" data-column="mfPlus" title="Перамогі за мафію">Мф+</th>
                        <th class="sortable" data-column="mfMinus" title="Паразы за мафію">Мф-</th>
                        <th class="sortable" data-column="dPlus" title="Перамогі за дона">Д+</th>
                        <th class="sortable" data-column="dMinus" title="Паразы за дона">Д-</th>
                        <th class="sortable" data-column="blackWins" title="Перамогі за чорных"><span class="color-indicator color-black"></span>+</th>
                        <th class="sortable" data-column="blackLosses" title="Паразы за чорных"><span class="color-indicator color-black"></span>-</th>
                        <th class="sortable" data-column="black" title="Агулам за чорных"><span class="color-indicator color-black"></span></th>
                        <th class="sortable" data-column="blackPct" title="Адсотак перамог за чорных"><span class="color-indicator color-black"></span> %</th>
                        <th class="sortable total-separator" data-column="totalWins" title="Усяго перамог">+</th>
                        <th class="sortable" data-column="totalLosses" title="Усяго параз">-</th>
                        <th class="sortable" data-column="total" title="Усяго гульняў">Усяго</th>
                        <th class="sortable" data-column="winPct" title="Адсотак перамог">%</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>

        <!-- Player Stats Page -->
        <div class="player-stats-page" id="playerStatsPage">
            <div class="player-stats-header">
                <div class="player-search-wrapper">
                    <div class="player-search-container">
                        <input 
                            type="text" 
                            id="playerSearchInput" 
                            class="player-search-input" 
                            placeholder="Увядзіце імя гульца..."
                            autocomplete="off"
                        />
                        <div class="autocomplete-dropdown" id="autocompleteDropdown"></div>
                    </div>
                    <button class="compare-btn" id="compareBtn">Параўнаць</button>
                    <div class="player-search-container secondary" id="secondarySearchContainer">
                        <input 
                            type="text" 
                            id="playerSearchInput2" 
                            class="player-search-input" 
                            placeholder="Выберыце другога гульца"
                            autocomplete="off"
                        />
                        <div class="autocomplete-dropdown" id="autocompleteDropdown2"></div>
                    </div>
                    <button class="close-compare-btn" id="closeCompareBtn" style="display: none;">&times;</button>
                </div>
            </div>
            <div class="player-stats-body" id="playerStatsBody">
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>Загрузка статыстыкі...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://mpasyybxqvzbnxciejqo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1wYXN5eWJ4cXZ6Ym54Y2llanFvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc2MTM5NjAsImV4cCI6MjA4MzE4OTk2MH0.W6OWShmcUwkFgCIRZfeGls0qM7bIFFzcBU06JsKy_cQ';

        let playerData = [];
        let filteredPlayerData = [];
        let allGamesData = [];
        let currentSort = { column: 'winPct', ascending: true };
        let selectedPlayers = [];
        let filterMinGames = 0;
        let filterMaxGames = 100;
        let maxGamesInData = 100;
        let defaultMinGamesThreshold = 25; // Will be loaded from DB
        let filterMinDate = '';
        let filterMaxDate = '';
        let playerFilterSelectedIndex = -1;
        let playerFilterItems = [];
        let showHiddenPlayers = false; // Track checkbox state for hidden players
        let activityPeriodDays = 30; // Will be loaded from DB
        let onlyActivePlayersFilter = true; // Track checkbox state for active players filter
        let lastGameDate = null; // Track most recent game date

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status show ' + type;
        }

        function mapSupabaseData(dbRow) {
            return {
                name: dbRow.name || '',
                mPlus: dbRow.m_plus || 0,
                mMinus: dbRow.m_minus || 0,
                shPlus: dbRow.sh_plus || 0,
                shMinus: dbRow.sh_minus || 0,
                mfPlus: dbRow.mf_plus || 0,
                mfMinus: dbRow.mf_minus || 0,
                dPlus: dbRow.d_plus || 0,
                dMinus: dbRow.d_minus || 0,
                red: dbRow.red_games || 0,
                black: dbRow.black_games || 0,
                total: dbRow.total_games || 0,
                winPct: parseFloat(dbRow.win_pct) || 0,
                isHidden: dbRow.is_hidden || false
            };
        }

        function sortData(column) {
            if (currentSort.column === column) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.column = column;
                currentSort.ascending = false; // Default to descending for better stats first
            }

            sortFilteredData();
            displayTable();
            updateSortIndicators();
        }

        function updateSortIndicators() {
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            const sortedTh = document.querySelector(`th[data-column="${currentSort.column}"]`);
            if (sortedTh) {
                sortedTh.classList.add(currentSort.ascending ? 'sorted-asc' : 'sorted-desc');
            }
        }

        function calculatePlayerDataFromGames(games) {
            const playerStatsMap = {};
            let globalLastDate = null;
            
            games.forEach(game => {
                const playerName = game.player_name;
                const gameDate = game.game_date;
                
                if (!playerStatsMap[playerName]) {
                    playerStatsMap[playerName] = {
                        name: playerName,
                        mPlus: 0, mMinus: 0,
                        shPlus: 0, shMinus: 0,
                        mfPlus: 0, mfMinus: 0,
                        dPlus: 0, dMinus: 0,
                        red: 0, black: 0,
                        redWins: 0, redLosses: 0,
                        blackWins: 0, blackLosses: 0,
                        total: 0,
                        totalWins: 0, totalLosses: 0,
                        isHidden: false,  // Default value, will be updated
                        lastPlayedDate: null  // Track last played date for this player
                    };
                }
                
                const stats = playerStatsMap[playerName];
                const won = game.player_won;
                const role = game.role_code;
                const isRed = (role === 'M' || role === 'Sh');
                
                // Track last played date for this player
                if (gameDate) {
                    const gameDateStr = gameDate.split('T')[0]; // Get YYYY-MM-DD part
                    if (!stats.lastPlayedDate || gameDateStr > stats.lastPlayedDate) {
                        stats.lastPlayedDate = gameDateStr;
                    }
                    
                    // Track global last game date
                    if (!globalLastDate || gameDateStr > globalLastDate) {
                        globalLastDate = gameDateStr;
                    }
                }
                
                // Update role stats
                if (role === 'M') {
                    won ? stats.mPlus++ : stats.mMinus++;
                } else if (role === 'Sh') {
                    won ? stats.shPlus++ : stats.shMinus++;
                } else if (role === 'Mf') {
                    won ? stats.mfPlus++ : stats.mfMinus++;
                } else if (role === 'D') {
                    won ? stats.dPlus++ : stats.dMinus++;
                }
                
                // Update team stats
                if (isRed) {
                    stats.red++;
                    if (won) {
                        stats.redWins++;
                    } else {
                        stats.redLosses++;
                    }
                } else {
                    stats.black++;
                    if (won) {
                        stats.blackWins++;
                    } else {
                        stats.blackLosses++;
                    }
                }
                
                // Update totals
                stats.total++;
                if (won) {
                    stats.totalWins++;
                } else {
                    stats.totalLosses++;
                }
            });
            
            // Update global last game date
            lastGameDate = globalLastDate;
            console.log('📅 Last game date:', lastGameDate);
            
            // Convert to array and calculate win percentages
            return Object.values(playerStatsMap).map(stats => ({
                ...stats,
                redPct: stats.red > 0 ? (stats.redWins / stats.red * 100) : 0,
                blackPct: stats.black > 0 ? (stats.blackWins / stats.black * 100) : 0,
                winPct: stats.total > 0 ? (stats.totalWins / stats.total * 100) : 0
            }));
        }

        // Fetch player hidden statuses and merge into player data
        async function enrichPlayerDataWithHiddenStatus(playerData) {
            try {
                const apiUrl = `${SUPABASE_URL}/rest/v1/player?select=name,is_hidden`;
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    console.error('Failed to fetch player hidden statuses');
                    return playerData;
                }
                
                const players = await response.json();
                const hiddenMap = {};
                players.forEach(p => {
                    hiddenMap[p.name] = p.is_hidden || false;
                });
                
                // Merge hidden status into player data
                return playerData.map(player => ({
                    ...player,
                    isHidden: hiddenMap[player.name] || false
                }));
            } catch (error) {
                console.error('Error enriching player data:', error);
                return playerData;
            }
        }

        function applyFilters() {
            console.log('Applying filters...', {
                filterMinDate,
                filterMaxDate,
                totalGames: allGamesData.length,
                filterMinGames,
                filterMaxGames,
                selectedPlayers
            });
            
            // First, filter games by date range
            let filteredGames = allGamesData;
            
            if (filterMinDate || filterMaxDate) {
                filteredGames = allGamesData.filter(game => {
                    if (!game.game_date) return true;
                    const gameDate = game.game_date.split('T')[0]; // Get YYYY-MM-DD part
                    
                    if (filterMinDate && gameDate < filterMinDate) return false;
                    if (filterMaxDate && gameDate > filterMaxDate) return false;
                    
                    return true;
                });
                console.log('After date filter:', filteredGames.length, 'games');
            }
            
            // Preserve hidden status before recalculation
            const hiddenStatusMap = {};
            playerData.forEach(p => {
                hiddenStatusMap[p.name] = p.isHidden || false;
            });
            
            // Recalculate player data from filtered games
            playerData = calculatePlayerDataFromGames(filteredGames);
            
            // Restore hidden status
            playerData.forEach(p => {
                p.isHidden = hiddenStatusMap[p.name] || false;
            });
            
            console.log('After recalc:', playerData.length, 'players');
            
            // Then filter by player names and game count
            filteredPlayerData = playerData.filter(player => {
                // Filter by selected players (if any)
                if (selectedPlayers.length > 0 && !selectedPlayers.includes(player.name)) {
                    return false;
                }
                
                // Filter by minimum and maximum games
                if (player.total < filterMinGames || player.total > filterMaxGames) {
                    return false;
                }
                
                // Filter by hidden status (always hide hidden players)
                if (player.isHidden) {
                    return false;
                }
                
                // Filter by activity period (only when checkbox is checked)
                if (onlyActivePlayersFilter && lastGameDate && player.lastPlayedDate) {
                    // Calculate cutoff date: lastGameDate - activityPeriodDays
                    const lastDate = new Date(lastGameDate);
                    const cutoffDate = new Date(lastDate);
                    cutoffDate.setDate(cutoffDate.getDate() - activityPeriodDays);
                    const cutoffDateStr = cutoffDate.toISOString().split('T')[0];
                    
                    // Filter out players whose last played date is before cutoff
                    if (player.lastPlayedDate < cutoffDateStr) {
                        return false;
                    }
                }
                
                return true;
            });
            
            console.log('Final filtered players:', filteredPlayerData.length);
            
            // Re-apply the current sort to maintain order
            sortFilteredData();
            displayTable();
        }

        function sortFilteredData() {
            const column = currentSort.column;
            const ascending = currentSort.ascending;

            filteredPlayerData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // For name, use string comparison
                if (column === 'name') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                    return ascending ? 
                        aVal.localeCompare(bVal) : 
                        bVal.localeCompare(aVal);
                }

                // For numbers
                return ascending ? 
                    aVal - bVal : 
                    bVal - aVal;
            });
        }

        function displayTable() {
            const tableBody = document.getElementById('tableBody');
            tableBody.innerHTML = '';

            filteredPlayerData.forEach(player => {
                const tr = document.createElement('tr');
                
                // Add click handler for player stats
                tr.addEventListener('click', () => {
                    showPlayerStats(player.name);
                });
                
                // Player name
                const tdName = document.createElement('td');
                tdName.textContent = player.name;
                tr.appendChild(tdName);

                // M+
                const tdMPlus = document.createElement('td');
                tdMPlus.textContent = player.mPlus;
                tdMPlus.className = 'win-cell';
                tdMPlus.title = 'Перамогі за мірных';
                tr.appendChild(tdMPlus);

                // M-
                const tdMMinus = document.createElement('td');
                tdMMinus.textContent = player.mMinus;
                tdMMinus.className = 'loss-cell';
                tdMMinus.title = 'Паразы за мірных';
                tr.appendChild(tdMMinus);

                // Sh+
                const tdShPlus = document.createElement('td');
                tdShPlus.textContent = player.shPlus;
                tdShPlus.className = 'win-cell';
                tdShPlus.title = 'Перамогі за шэрыфа';
                tr.appendChild(tdShPlus);

                // Sh-
                const tdShMinus = document.createElement('td');
                tdShMinus.textContent = player.shMinus;
                tdShMinus.className = 'loss-cell';
                tdShMinus.title = 'Паразы за шэрыфа';
                tr.appendChild(tdShMinus);

                // Red wins
                const tdRedWins = document.createElement('td');
                tdRedWins.textContent = player.redWins;
                tdRedWins.className = 'win-cell';
                tdRedWins.title = 'Перамогі за чырвоных';
                tr.appendChild(tdRedWins);

                // Red losses
                const tdRedLosses = document.createElement('td');
                tdRedLosses.textContent = player.redLosses;
                tdRedLosses.className = 'loss-cell';
                tdRedLosses.title = 'Паразы за чырвоных';
                tr.appendChild(tdRedLosses);

                // Red team
                const tdRed = document.createElement('td');
                tdRed.textContent = player.red;
                tdRed.title = 'Агулам за чырвоных';
                tr.appendChild(tdRed);

                // Red percentage
                const tdRedPct = document.createElement('td');
                tdRedPct.textContent = player.redPct.toFixed(1) + '%';
                tdRedPct.className = 'percentage-cell';
                tdRedPct.style.fontWeight = 'normal';
                tdRedPct.title = 'Адсотак перамог за чырвоных';
                tr.appendChild(tdRedPct);

                // Mf+
                const tdMfPlus = document.createElement('td');
                tdMfPlus.textContent = player.mfPlus;
                tdMfPlus.className = 'win-cell';
                tdMfPlus.title = 'Перамогі за мафію';
                tr.appendChild(tdMfPlus);

                // Mf-
                const tdMfMinus = document.createElement('td');
                tdMfMinus.textContent = player.mfMinus;
                tdMfMinus.className = 'loss-cell';
                tdMfMinus.title = 'Паразы за мафію';
                tr.appendChild(tdMfMinus);

                // D+
                const tdDPlus = document.createElement('td');
                tdDPlus.textContent = player.dPlus;
                tdDPlus.className = 'win-cell';
                tdDPlus.title = 'Перамогі за дона';
                tr.appendChild(tdDPlus);

                // D-
                const tdDMinus = document.createElement('td');
                tdDMinus.textContent = player.dMinus;
                tdDMinus.className = 'loss-cell';
                tdDMinus.title = 'Паразы за дона';
                tr.appendChild(tdDMinus);

                // Black wins
                const tdBlackWins = document.createElement('td');
                tdBlackWins.textContent = player.blackWins;
                tdBlackWins.className = 'win-cell';
                tdBlackWins.title = 'Перамогі за чорных';
                tr.appendChild(tdBlackWins);

                // Black losses
                const tdBlackLosses = document.createElement('td');
                tdBlackLosses.textContent = player.blackLosses;
                tdBlackLosses.className = 'loss-cell';
                tdBlackLosses.title = 'Паразы за чорных';
                tr.appendChild(tdBlackLosses);

                // Black team
                const tdBlack = document.createElement('td');
                tdBlack.textContent = player.black;
                tdBlack.title = 'Агулам за чорных';
                tr.appendChild(tdBlack);

                // Black percentage
                const tdBlackPct = document.createElement('td');
                tdBlackPct.textContent = player.blackPct.toFixed(1) + '%';
                tdBlackPct.className = 'percentage-cell';
                tdBlackPct.style.fontWeight = 'normal';
                tdBlackPct.title = 'Адсотак перамог за чорных';
                tr.appendChild(tdBlackPct);

                // Total wins
                const tdTotalWins = document.createElement('td');
                tdTotalWins.textContent = player.totalWins;
                tdTotalWins.className = 'win-cell total-separator';
                tdTotalWins.style.fontWeight = 'bold';
                tdTotalWins.title = 'Усяго перамог';
                tr.appendChild(tdTotalWins);

                // Total losses
                const tdTotalLosses = document.createElement('td');
                tdTotalLosses.textContent = player.totalLosses;
                tdTotalLosses.className = 'loss-cell';
                tdTotalLosses.style.fontWeight = 'bold';
                tdTotalLosses.title = 'Усяго параз';
                tr.appendChild(tdTotalLosses);

                // Total games
                const tdTotal = document.createElement('td');
                tdTotal.textContent = player.total;
                tdTotal.className = 'total-cell';
                tdTotal.style.fontWeight = 'bold';
                tdTotal.title = 'Усяго гульняў';
                tr.appendChild(tdTotal);

                // Win percentage
                const tdPct = document.createElement('td');
                tdPct.textContent = player.winPct.toFixed(1) + '%';
                tdPct.className = 'percentage-cell';
                tdPct.title = 'Адсотак перамог';
                tr.appendChild(tdPct);

                tableBody.appendChild(tr);
            });
        }

        // Role code to Belarusian name mapping
        const roleNames = {
            'M': 'Мірны жыхар',
            'Sh': 'Шэрыф',
            'Mf': 'Мафія',
            'D': 'Дон'
        };

        // Helper function to anonymize hidden player names
        function getDisplayName(playerName) {
            const player = playerData.find(p => p.name === playerName);
            return (player && player.isHidden) ? '[Ананім]' : playerName;
        }

        // Autocomplete state
        let autocompleteSelectedIndex = -1;
        let autocompleteItems = [];
        let autocompleteSelectedIndex2 = -1;
        let autocompleteItems2 = [];
        
        // Comparison mode state
        let comparisonMode = false;
        let selectedPlayer1 = null;
        let selectedPlayer2 = null;

        // Partner/Opponent table state
        let partnerTableData = [];
        let partnerTableSort = { column: 'totalTotal', ascending: false };
        let partnerSectionMode = 'total'; // 'together', 'against', 'total'

        // Navigation Control Functions
        function showPlayerStatsView() {
            // Hide table view and filters
            document.getElementById('tableWrapper').style.display = 'none';
            document.getElementById('tableControls').style.display = 'none';
            document.getElementById('filtersContainer').style.display = 'none';
            
            // Show player stats page
            document.getElementById('playerStatsPage').classList.add('show');
            
            // Update header
            const header = document.getElementById('header');
            const backButton = document.getElementById('backButton');
            const headerTitle = document.getElementById('headerTitle');
            const headerSubtitle = document.getElementById('headerSubtitle');
            
            header.classList.add('player-view');
            backButton.classList.add('show');
            headerSubtitle.style.display = 'none';
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function showMainTableView() {
            // Show table view and filters
            document.getElementById('tableWrapper').style.display = 'block';
            document.getElementById('tableControls').style.display = '';
            document.getElementById('filtersContainer').style.display = 'block';
            
            // Hide player stats page
            document.getElementById('playerStatsPage').classList.remove('show');
            
            // Update header
            const header = document.getElementById('header');
            const backButton = document.getElementById('backButton');
            const headerTitle = document.getElementById('headerTitle');
            const headerSubtitle = document.getElementById('headerSubtitle');
            
            header.classList.remove('player-view');
            backButton.classList.remove('show');
            headerTitle.textContent = 'МАФІЯ';
            headerSubtitle.style.display = 'block';
            
            closeAutocomplete();
            closeAutocomplete2();
            
            // Reset comparison mode
            comparisonMode = false;
            selectedPlayer1 = null;
            selectedPlayer2 = null;
            document.getElementById('secondarySearchContainer').classList.remove('show');
            document.getElementById('closeCompareBtn').style.display = 'none';
            document.getElementById('compareBtn').style.display = 'block';
            document.getElementById('playerSearchInput2').value = '';
            document.getElementById('playerSearchInput').value = '';
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        function closeAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.classList.remove('show');
            autocompleteSelectedIndex = -1;
            autocompleteItems = [];
        }

        function closeAutocomplete2() {
            const dropdown = document.getElementById('autocompleteDropdown2');
            dropdown.classList.remove('show');
            autocompleteSelectedIndex2 = -1;
            autocompleteItems2 = [];
        }

        // Filter players by search term
        function filterPlayers(searchTerm, excludePlayer = null) {
            let filtered = playerData;
            // Always exclude hidden players from autocomplete
            filtered = filtered.filter(player => !player.isHidden);
            if (excludePlayer) {
                filtered = filtered.filter(player => player.name !== excludePlayer);
            }
            if (!searchTerm) return filtered;
            const term = searchTerm.toLowerCase();
            return filtered.filter(player => 
                player.name.toLowerCase().includes(term)
            );
        }

        // Render autocomplete dropdown
        function renderAutocomplete(filteredPlayers, isSecondary = false) {
            const dropdownId = isSecondary ? 'autocompleteDropdown2' : 'autocompleteDropdown';
            const dropdown = document.getElementById(dropdownId);
            const selectedIndex = isSecondary ? autocompleteSelectedIndex2 : autocompleteSelectedIndex;
            
            if (filteredPlayers.length === 0) {
                dropdown.innerHTML = '<div class="autocomplete-item no-results">Нічога не знойдзена</div>';
                dropdown.classList.add('show');
                return;
            }

            if (isSecondary) {
                autocompleteItems2 = filteredPlayers;
            } else {
                autocompleteItems = filteredPlayers;
            }

            const items = filteredPlayers.map((player, index) => {
                const className = index === selectedIndex ? 'autocomplete-item selected' : 'autocomplete-item';
                return `<div class="${className}" data-index="${index}" data-name="${player.name}">${player.name}</div>`;
            }).join('');

            dropdown.innerHTML = items;
            dropdown.classList.add('show');

            // Add click handlers to items
            dropdown.querySelectorAll('.autocomplete-item:not(.no-results)').forEach(item => {
                item.addEventListener('click', (e) => {
                    const playerName = e.target.dataset.name;
                    if (isSecondary) {
                        selectPlayer2(playerName);
                    } else {
                        selectPlayer(playerName);
                    }
                });
            });

            // Scroll selected item into view
            if (selectedIndex >= 0) {
                const selectedItem = dropdown.querySelector('.autocomplete-item.selected');
                if (selectedItem) {
                    selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
        }

        // Select a player from autocomplete
        function selectPlayer(playerName) {
            const input = document.getElementById('playerSearchInput');
            input.value = playerName;
            closeAutocomplete();
            selectedPlayer1 = playerName;
            
            if (comparisonMode && selectedPlayer2) {
                showComparisonStats(selectedPlayer1, selectedPlayer2);
            } else if (!comparisonMode) {
                showPlayerStats(playerName);
            }
        }

        // Select second player from autocomplete
        function selectPlayer2(playerName) {
            const input = document.getElementById('playerSearchInput2');
            input.value = playerName;
            closeAutocomplete2();
            selectedPlayer2 = playerName;
            
            if (selectedPlayer1) {
                showComparisonStats(selectedPlayer1, selectedPlayer2);
            }
        }

        // Handle autocomplete input for first player
        const playerSearchInput = document.getElementById('playerSearchInput');
        playerSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.trim();
            if (searchTerm.length === 0) {
                closeAutocomplete();
                return;
            }
            // Exclude player 2 if in comparison mode
            const excludePlayer = comparisonMode ? selectedPlayer2 : null;
            const filtered = filterPlayers(searchTerm, excludePlayer);
            renderAutocomplete(filtered, false);
        });

        // Handle autocomplete input for second player
        const playerSearchInput2 = document.getElementById('playerSearchInput2');
        playerSearchInput2.addEventListener('input', (e) => {
            const searchTerm = e.target.value.trim();
            if (searchTerm.length === 0) {
                // Show all players sorted alphabetically when input is empty
                const allPlayers = filterPlayers('', selectedPlayer1);
                const sortedPlayers = [...allPlayers].sort((a, b) => a.name.localeCompare(b.name));
                renderAutocomplete(sortedPlayers, true);
                return;
            }
            const filtered = filterPlayers(searchTerm, selectedPlayer1);
            renderAutocomplete(filtered, true);
        });

        // Show all players sorted alphabetically when focusing on second player input
        playerSearchInput2.addEventListener('focus', (e) => {
            const allPlayers = filterPlayers('', selectedPlayer1);
            const sortedPlayers = [...allPlayers].sort((a, b) => a.name.localeCompare(b.name));
            renderAutocomplete(sortedPlayers, true);
        });

        // Handle keyboard navigation in first autocomplete
        playerSearchInput.addEventListener('keydown', (e) => {
            const dropdown = document.getElementById('autocompleteDropdown');
            
            if (e.key === 'Escape') {
                e.preventDefault();
                if (dropdown.classList.contains('show')) {
                    closeAutocomplete();
                } else {
                    showMainTableView();
                }
                return;
            }

            if (!dropdown.classList.contains('show')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, autocompleteItems.length - 1);
                renderAutocomplete(autocompleteItems, false);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                renderAutocomplete(autocompleteItems, false);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteSelectedIndex >= 0 && autocompleteItems[autocompleteSelectedIndex]) {
                    selectPlayer(autocompleteItems[autocompleteSelectedIndex].name);
                } else if (autocompleteItems.length === 1) {
                    selectPlayer(autocompleteItems[0].name);
                }
            }
        });

        // Handle keyboard navigation in second autocomplete
        playerSearchInput2.addEventListener('keydown', (e) => {
            const dropdown = document.getElementById('autocompleteDropdown2');
            
            if (e.key === 'Escape') {
                e.preventDefault();
                if (dropdown.classList.contains('show')) {
                    closeAutocomplete2();
                }
                return;
            }

            if (!dropdown.classList.contains('show')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                autocompleteSelectedIndex2 = Math.min(autocompleteSelectedIndex2 + 1, autocompleteItems2.length - 1);
                renderAutocomplete(autocompleteItems2, true);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                autocompleteSelectedIndex2 = Math.max(autocompleteSelectedIndex2 - 1, -1);
                renderAutocomplete(autocompleteItems2, true);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteSelectedIndex2 >= 0 && autocompleteItems2[autocompleteSelectedIndex2]) {
                    selectPlayer2(autocompleteItems2[autocompleteSelectedIndex2].name);
                } else if (autocompleteItems2.length === 1) {
                    selectPlayer2(autocompleteItems2[0].name);
                }
            }
        });

        // Close autocomplete when clicking outside
        document.addEventListener('click', (e) => {
            const searchContainers = document.querySelectorAll('.player-search-container');
            let clickedInside = false;
            searchContainers.forEach(container => {
                if (container.contains(e.target)) {
                    clickedInside = true;
                }
            });
            if (!clickedInside) {
                closeAutocomplete();
                closeAutocomplete2();
            }
            
            // Close player filter dropdown when clicking outside
            const playerFilterContainer = document.getElementById('playerFilterContainer');
            if (playerFilterContainer && !playerFilterContainer.contains(e.target)) {
                closePlayerFilterDropdown();
            }
        });

        // Player filter functions
        function closePlayerFilterDropdown() {
            const dropdown = document.getElementById('playerFilterDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                playerFilterSelectedIndex = -1;
                playerFilterItems = [];
            }
        }

        function renderPlayerFilterDropdown(filteredPlayers) {
            const dropdown = document.getElementById('playerFilterDropdown');
            
            if (filteredPlayers.length === 0) {
                dropdown.innerHTML = '<div class="player-filter-item disabled">Нічога не знойдзена</div>';
                dropdown.classList.add('show');
                return;
            }

            playerFilterItems = filteredPlayers;

            const items = filteredPlayers.map((player, index) => {
                const isSelected = selectedPlayers.includes(player.name);
                const className = index === playerFilterSelectedIndex ? 
                    'player-filter-item selected' : 
                    'player-filter-item';
                const disabledClass = isSelected ? ' disabled' : '';
                return `<div class="${className}${disabledClass}" data-index="${index}" data-name="${player.name}">${player.name}${isSelected ? ' (выбрана)' : ''}</div>`;
            }).join('');

            dropdown.innerHTML = items;
            dropdown.classList.add('show');

            // Add click handlers
            dropdown.querySelectorAll('.player-filter-item:not(.disabled)').forEach(item => {
                item.addEventListener('click', (e) => {
                    const playerName = e.target.dataset.name;
                    if (!selectedPlayers.includes(playerName)) {
                        addPlayerTag(playerName);
                    }
                });
            });

            // Scroll selected item into view
            if (playerFilterSelectedIndex >= 0) {
                const selectedItem = dropdown.querySelector('.player-filter-item.selected');
                if (selectedItem) {
                    selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                }
            }
        }

        function addPlayerTag(playerName) {
            if (selectedPlayers.includes(playerName)) return;
            
            selectedPlayers.push(playerName);
            renderPlayerTags();
            
            const input = document.getElementById('playerFilterInput');
            input.value = '';
            closePlayerFilterDropdown();
            
            applyFilters();
        }

        function removePlayerTag(playerName) {
            selectedPlayers = selectedPlayers.filter(p => p !== playerName);
            renderPlayerTags();
            applyFilters();
        }

        function renderPlayerTags() {
            const container = document.getElementById('playerFilterContainer');
            const input = document.getElementById('playerFilterInput');
            
            // Remove existing tags
            container.querySelectorAll('.player-tag').forEach(tag => tag.remove());
            
            // Add new tags before the input
            selectedPlayers.forEach(playerName => {
                const tag = document.createElement('span');
                tag.className = 'player-tag';
                tag.innerHTML = `
                    ${playerName}
                    <span class="player-tag-remove" data-name="${playerName}">&times;</span>
                `;
                container.insertBefore(tag, input);
                
                // Add click handler to remove button
                tag.querySelector('.player-tag-remove').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removePlayerTag(e.target.dataset.name);
                });
            });
        }

        // Player filter input handler
        function setupPlayerFilter() {
            const input = document.getElementById('playerFilterInput');
            const container = document.getElementById('playerFilterContainer');
            
            // Focus input when clicking on container
            container.addEventListener('click', (e) => {
                if (e.target === container || e.target === input) {
                    input.focus();
                }
            });
            
            // Handle input
            input.addEventListener('input', (e) => {
                const searchTerm = e.target.value.trim();
                if (searchTerm.length === 0) {
                    closePlayerFilterDropdown();
                    return;
                }
                
                // Filter players excluding already selected ones
                const filtered = playerData.filter(player => 
                    !selectedPlayers.includes(player.name) &&
                    player.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
                
                renderPlayerFilterDropdown(filtered);
            });
            
            // Handle keyboard navigation
            input.addEventListener('keydown', (e) => {
                const dropdown = document.getElementById('playerFilterDropdown');
                
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closePlayerFilterDropdown();
                    input.blur();
                    return;
                }

                if (!dropdown.classList.contains('show')) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    playerFilterSelectedIndex = Math.min(playerFilterSelectedIndex + 1, playerFilterItems.length - 1);
                    renderPlayerFilterDropdown(playerFilterItems);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    playerFilterSelectedIndex = Math.max(playerFilterSelectedIndex - 1, -1);
                    renderPlayerFilterDropdown(playerFilterItems);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (playerFilterSelectedIndex >= 0 && playerFilterItems[playerFilterSelectedIndex]) {
                        const playerName = playerFilterItems[playerFilterSelectedIndex].name;
                        if (!selectedPlayers.includes(playerName)) {
                            addPlayerTag(playerName);
                        }
                    } else if (playerFilterItems.length === 1) {
                        const playerName = playerFilterItems[0].name;
                        if (!selectedPlayers.includes(playerName)) {
                            addPlayerTag(playerName);
                        }
                    }
                }
            });
        }

        // Toggle filters visibility
        function setupFiltersToggle() {
            const toggle = document.getElementById('filtersToggle');
            const content = document.getElementById('filtersContent');
            const icon = document.getElementById('filtersToggleIcon');
            
            toggle.addEventListener('click', () => {
                content.classList.toggle('expanded');
                icon.classList.toggle('expanded');
            });
        }

        // Games filter handlers
        function setupGamesFilter() {
            const minSlider = document.getElementById('minGamesSlider');
            const maxSlider = document.getElementById('maxGamesSlider');
            const minDisplay = document.getElementById('minGamesDisplay');
            const maxDisplay = document.getElementById('maxGamesDisplay');
            const sliderRange = document.getElementById('sliderRange');
            
            // Calculate max games from data
            maxGamesInData = Math.max(...playerData.map(p => p.total));
            
            // Set slider attributes
            minSlider.min = 0;
            minSlider.max = maxGamesInData;
            maxSlider.min = 0;
            maxSlider.max = maxGamesInData;
            
            // Set initial values using threshold from DB
            filterMinGames = Math.min(defaultMinGamesThreshold, maxGamesInData);
            filterMaxGames = maxGamesInData;
            minSlider.value = filterMinGames;
            maxSlider.value = filterMaxGames;
            minDisplay.textContent = filterMinGames;
            maxDisplay.textContent = filterMaxGames;
            
            updateSliderRange();
            applyFilters(); // Apply initial filter with default values
            
            // Handle min slider
            minSlider.addEventListener('input', () => {
                let minValue = parseInt(minSlider.value);
                let maxValue = parseInt(maxSlider.value);
                
                // Ensure min doesn't exceed max
                if (minValue > maxValue) {
                    minValue = maxValue;
                    minSlider.value = minValue;
                }
                
                filterMinGames = minValue;
                minDisplay.textContent = minValue;
                updateSliderRange();
                applyFilters();
            });
            
            // Handle max slider
            maxSlider.addEventListener('input', () => {
                let minValue = parseInt(minSlider.value);
                let maxValue = parseInt(maxSlider.value);
                
                // Ensure max doesn't go below min
                if (maxValue < minValue) {
                    maxValue = minValue;
                    maxSlider.value = maxValue;
                }
                
                filterMaxGames = maxValue;
                maxDisplay.textContent = maxValue;
                updateSliderRange();
                applyFilters();
            });
        }
        
        function updateSliderRange() {
            const sliderRange = document.getElementById('sliderRange');
            const minPercent = (filterMinGames / maxGamesInData) * 100;
            const maxPercent = (filterMaxGames / maxGamesInData) * 100;
            
            sliderRange.style.left = minPercent + '%';
            sliderRange.style.width = (maxPercent - minPercent) + '%';
        }

        // Date filter handlers
        async function setupDateFilter() {
            const minDateInput = document.getElementById('minDateFilter');
            const maxDateInput = document.getElementById('maxDateFilter');
            
            // Helper function to convert yyyy-MM-dd to dd.MM.yyyy
            const formatDateDisplay = (isoDate) => {
                const [year, month, day] = isoDate.split('-');
                return `${day}.${month}.${year}`;
            };
            
            // Helper function to convert dd.MM.yyyy to yyyy-MM-dd
            const parseDateInput = (displayDate) => {
                const parts = displayDate.split('.');
                if (parts.length === 3) {
                    const [day, month, year] = parts;
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }
                return null;
            };
            
            // Fetch min and max dates directly from the database
            try {
                const minDateUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=game_date&order=game_date.asc&limit=1`;
                const maxDateUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=game_date&order=game_date.desc&limit=1`;
                
                const [minResponse, maxResponse] = await Promise.all([
                    fetch(minDateUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    }),
                    fetch(maxDateUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    })
                ]);
                
                const minData = await minResponse.json();
                const maxData = await maxResponse.json();
                
                if (minData.length > 0 && maxData.length > 0) {
                    const minDate = minData[0].game_date.split('T')[0];
                    const maxDate = maxData[0].game_date.split('T')[0];
                    
                    console.log('Date range from DB:', minDate, 'to', maxDate);
                    
                    // Set default values in yyyy-MM-dd format for filtering
                    filterMinDate = minDate;
                    filterMaxDate = maxDate;
                    
                    // Display in dd.MM.yyyy format
                    minDateInput.value = formatDateDisplay(minDate);
                    maxDateInput.value = formatDateDisplay(maxDate);
                    
                    // Store the internal values as data attributes
                    minDateInput.dataset.isoDate = minDate;
                    maxDateInput.dataset.isoDate = maxDate;
                }
            } catch (error) {
                console.error('Error fetching date range:', error);
            }
            
            // Make inputs editable and handle click to show date picker
            minDateInput.removeAttribute('readonly');
            maxDateInput.removeAttribute('readonly');
            
            // Handle date changes for min date
            minDateInput.addEventListener('click', function() {
                const tempInput = document.createElement('input');
                tempInput.type = 'date';
                tempInput.value = this.dataset.isoDate || filterMinDate;
                tempInput.style.position = 'absolute';
                tempInput.style.opacity = '0';
                document.body.appendChild(tempInput);
                
                tempInput.addEventListener('change', () => {
                    if (tempInput.value) {
                        filterMinDate = tempInput.value;
                        minDateInput.value = formatDateDisplay(tempInput.value);
                        minDateInput.dataset.isoDate = tempInput.value;
                        applyFilters();
                    }
                    document.body.removeChild(tempInput);
                });
                
                tempInput.showPicker ? tempInput.showPicker() : tempInput.click();
            });
            
            // Handle date changes for max date
            maxDateInput.addEventListener('click', function() {
                const tempInput = document.createElement('input');
                tempInput.type = 'date';
                tempInput.value = this.dataset.isoDate || filterMaxDate;
                tempInput.style.position = 'absolute';
                tempInput.style.opacity = '0';
                document.body.appendChild(tempInput);
                
                tempInput.addEventListener('change', () => {
                    if (tempInput.value) {
                        filterMaxDate = tempInput.value;
                        maxDateInput.value = formatDateDisplay(tempInput.value);
                        maxDateInput.dataset.isoDate = tempInput.value;
                        applyFilters();
                    }
                    document.body.removeChild(tempInput);
                });
                
                tempInput.showPicker ? tempInput.showPicker() : tempInput.click();
            });
        }

        function setupActivePlayersFilter() {
            const checkbox = document.getElementById('onlyActiveCheckbox');
            if (checkbox) {
                // Initialize filter state from checkbox's default checked state
                onlyActivePlayersFilter = checkbox.checked;
                
                checkbox.addEventListener('change', () => {
                    onlyActivePlayersFilter = checkbox.checked;
                    
                    // Calculate fromDate for logging
                    let fromDate = null;
                    if (lastGameDate && activityPeriodDays) {
                        const lastDate = new Date(lastGameDate);
                        const cutoffDate = new Date(lastDate);
                        cutoffDate.setDate(cutoffDate.getDate() - activityPeriodDays);
                        fromDate = cutoffDate.toISOString().split('T')[0];
                    }
                    
                    console.log('Only active players filter:', {
                        enabled: onlyActivePlayersFilter,
                        activityPeriodDays: activityPeriodDays,
                        lastGameDate: lastGameDate,
                        fromDate: fromDate
                    });
                    
                    applyFilters();
                });
            }
        }

        // Compare button handler
        document.getElementById('compareBtn').addEventListener('click', () => {
            comparisonMode = true;
            document.getElementById('secondarySearchContainer').classList.add('show');
            document.getElementById('closeCompareBtn').style.display = 'flex';
            document.getElementById('compareBtn').style.display = 'none';
            
            // Focus on second input
            setTimeout(() => {
                document.getElementById('playerSearchInput2').focus();
            }, 100);
        });

        // Close compare button handler
        document.getElementById('closeCompareBtn').addEventListener('click', () => {
            comparisonMode = false;
            selectedPlayer2 = null;
            document.getElementById('secondarySearchContainer').classList.remove('show');
            document.getElementById('closeCompareBtn').style.display = 'none';
            document.getElementById('compareBtn').style.display = 'block';
            document.getElementById('playerSearchInput2').value = '';
            closeAutocomplete2();
            
            // Reload single player view (already shown)
            if (selectedPlayer1) {
                showPlayerStats(selectedPlayer1);
            }
        });

        // Back button handler
        document.getElementById('backButton').addEventListener('click', showMainTableView);

        // Columns toggle button handler
        const columnsToggleBtn = document.getElementById('columnsToggleBtn');
        const columnsToggleText = document.getElementById('columnsToggleText');
        const tableWrapper = document.getElementById('tableWrapper');

        columnsToggleBtn?.addEventListener('click', () => {
            tableWrapper.classList.toggle('show-all-columns');
            const isExpanded = tableWrapper.classList.contains('show-all-columns');
            columnsToggleText.textContent = isExpanded ? 'Схаваць дадатковыя калонкі' : 'Паказаць усе калонкі';
        });

        // ESC key to go back (when not in input field)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const playerStatsPage = document.getElementById('playerStatsPage');
                if (playerStatsPage.classList.contains('show') && 
                    document.activeElement !== playerSearchInput && 
                    document.activeElement !== playerSearchInput2) {
                    e.preventDefault();
                    showMainTableView();
                }
            }
        });

        // Calculate summary statistics from game data
        function calculatePlayerStats(games) {
            const stats = {
                M: { wins: 0, losses: 0 },
                Sh: { wins: 0, losses: 0 },
                Mf: { wins: 0, losses: 0 },
                D: { wins: 0, losses: 0 }
            };

            games.forEach(game => {
                const role = game.role_code;
                if (stats[role]) {
                    if (game.player_won) {
                        stats[role].wins++;
                    } else {
                        stats[role].losses++;
                    }
                }
            });

            // Calculate totals
            const redWins = stats.M.wins + stats.Sh.wins;
            const redLosses = stats.M.losses + stats.Sh.losses;
            const blackWins = stats.Mf.wins + stats.D.wins;
            const blackLosses = stats.Mf.losses + stats.D.losses;
            const totalWins = redWins + blackWins;
            const totalLosses = redLosses + blackLosses;
            const totalGames = totalWins + totalLosses;
            const winPct = totalGames > 0 ? (totalWins / totalGames * 100) : 0;

            return {
                byRole: stats,
                red: { wins: redWins, losses: redLosses },
                black: { wins: blackWins, losses: blackLosses },
                total: { wins: totalWins, losses: totalLosses, games: totalGames, winPct }
            };
        }

        // Fetch player game data from Supabase
        async function fetchPlayerGames(playerName) {
            try {
                const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?player_name=eq.${encodeURIComponent(playerName)}&order=game_id.desc`;
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Памылка загрузкі дадзеных. Статус: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching player games:', error);
                throw error;
            }
        }

        // Fetch all game participants for given game IDs
        async function fetchGameParticipants(gameIds) {
            try {
                if (!gameIds || gameIds.length === 0) {
                    return [];
                }

                // Build query with OR conditions for all game IDs
                const gameIdFilters = gameIds.map(id => `game_id.eq.${id}`).join(',');
                const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?or=(${gameIdFilters})`;
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Памылка загрузкі дадзеных. Статус: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching game participants:', error);
                throw error;
            }
        }

        // Calculate head-to-head statistics
        function calculateHeadToHeadStats(games1, games2) {
            // Find common games
            const player1GameMap = {};
            games1.forEach(game => {
                player1GameMap[game.game_id] = game;
            });

            const commonGames = [];
            games2.forEach(game => {
                if (player1GameMap[game.game_id]) {
                    commonGames.push({
                        player1: player1GameMap[game.game_id],
                        player2: game
                    });
                }
            });

            // Calculate stats for each combination
            const stats = {
                redRed: { wins: 0, losses: 0, roles: {} },      // Both red team
                redBlack: { wins: 0, losses: 0, roles: {} },    // P1 red, P2 black
                blackRed: { wins: 0, losses: 0, roles: {} },    // P1 black, P2 red
                blackBlack: { wins: 0, losses: 0, roles: {} }   // Both black team
            };

            commonGames.forEach(({ player1, player2 }) => {
                const p1IsRed = player1.role_code === 'M' || player1.role_code === 'Sh';
                const p2IsRed = player2.role_code === 'M' || player2.role_code === 'Sh';
                const redWon = !player1.mafia_won;
                
                // Normalize role codes (Mf -> Ma for consistency)
                const p1RoleNormalized = player1.role_code === 'Mf' ? 'Ma' : player1.role_code;
                const p2RoleNormalized = player2.role_code === 'Mf' ? 'Ma' : player2.role_code;
                
                // Create role combination key
                const roleKey = `${p1RoleNormalized}-${p2RoleNormalized}`;

                if (p1IsRed && p2IsRed) {
                    if (redWon) stats.redRed.wins++;
                    else stats.redRed.losses++;
                    // Track role-specific stats
                    if (!stats.redRed.roles[roleKey]) {
                        stats.redRed.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.redRed.roles[roleKey].wins++;
                    else stats.redRed.roles[roleKey].losses++;
                } else if (p1IsRed && !p2IsRed) {
                    if (redWon) stats.redBlack.wins++;
                    else stats.redBlack.losses++;
                    // Track role-specific stats
                    if (!stats.redBlack.roles[roleKey]) {
                        stats.redBlack.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.redBlack.roles[roleKey].wins++;
                    else stats.redBlack.roles[roleKey].losses++;
                } else if (!p1IsRed && p2IsRed) {
                    if (redWon) stats.blackRed.wins++;
                    else stats.blackRed.losses++;
                    // Track role-specific stats
                    if (!stats.blackRed.roles[roleKey]) {
                        stats.blackRed.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.blackRed.roles[roleKey].wins++;
                    else stats.blackRed.roles[roleKey].losses++;
                } else {
                    if (redWon) stats.blackBlack.losses++;
                    else stats.blackBlack.wins++;
                    // Track role-specific stats
                    if (!stats.blackBlack.roles[roleKey]) {
                        stats.blackBlack.roles[roleKey] = { wins: 0, losses: 0 };
                    }
                    if (redWon) stats.blackBlack.roles[roleKey].losses++;
                    else stats.blackBlack.roles[roleKey].wins++;
                }
            });

            return stats;
        }

        // Calculate partner and opponent statistics
        function calculatePartnerOpponentStats(currentPlayerGames, allGameParticipants) {
            const currentPlayerName = currentPlayerGames[0]?.player_name;
            if (!currentPlayerName) return [];

            // Create a map of game_id -> current player's role info
            const currentPlayerGameMap = {};
            currentPlayerGames.forEach(game => {
                currentPlayerGameMap[game.game_id] = {
                    role_code: game.role_code,
                    player_won: game.player_won,
                    isRed: game.role_code === 'M' || game.role_code === 'Sh'
                };
            });

            // Group all participants by player name
            const playerStatsMap = {};
            
            allGameParticipants.forEach(participant => {
                // Skip the current player
                if (participant.player_name === currentPlayerName) return;
                
                const gameId = participant.game_id;
                const currentPlayerInfo = currentPlayerGameMap[gameId];
                
                // Skip if current player wasn't in this game
                if (!currentPlayerInfo) return;
                
                const playerName = participant.player_name;
                const participantIsRed = participant.role_code === 'M' || participant.role_code === 'Sh';
                
                // Initialize player stats if not exists
                if (!playerStatsMap[playerName]) {
                    playerStatsMap[playerName] = {
                        name: playerName,
                        together: { total: 0, wins: 0, losses: 0 },
                        against: { total: 0, wins: 0, losses: 0 },
                        total: { total: 0, wins: 0, losses: 0 }
                    };
                }
                
                const stats = playerStatsMap[playerName];
                const sameTeam = currentPlayerInfo.isRed === participantIsRed;
                const currentPlayerWon = currentPlayerInfo.player_won;
                
                // Update total stats
                stats.total.total++;
                if (currentPlayerWon) {
                    stats.total.wins++;
                } else {
                    stats.total.losses++;
                }
                
                // Update together/against stats
                if (sameTeam) {
                    stats.together.total++;
                    if (currentPlayerWon) {
                        stats.together.wins++;
                    } else {
                        stats.together.losses++;
                    }
                } else {
                    stats.against.total++;
                    if (currentPlayerWon) {
                        stats.against.wins++;
                    } else {
                        stats.against.losses++;
                    }
                }
            });

            // Convert to array and sort by total games descending
            const playerStatsArray = Object.values(playerStatsMap);
            playerStatsArray.sort((a, b) => b.total.total - a.total.total);
            
            return playerStatsArray;
        }

        // Helper function for Belarusian plural forms
        function getWinsForm(n) {
            const mod10 = n % 10;
            const mod100 = n % 100;
            
            if (mod100 >= 11 && mod100 <= 14) {
                return 'перамог';
            }
            if (mod10 === 1) {
                return 'перамога';
            }
            if (mod10 >= 2 && mod10 <= 4) {
                return 'перамогі';
            }
            return 'перамог';
        }

        function getGamesForm(m) {
            const mod10 = m % 10;
            const mod100 = m % 100;
            
            if (mod100 >= 11 && mod100 <= 14) {
                return 'гульнях';
            }
            if (mod10 === 1) {
                return 'гульні';
            }
            return 'гульнях';
        }

        // Get role display name
        function getRoleDisplayName(roleCode) {
            const roleNames = {
                'M': 'Мірны жыхар',
                'Sh': 'Шэрыф',
                'Ma': 'Мафія',
                'Mf': 'Мафія',
                'D': 'Дон'
            };
            return roleNames[roleCode] || roleCode;
        }

        // Get role color class (for text color)
        function getRoleColorClass(roleCode) {
            // Red team roles
            if (roleCode === 'M' || roleCode === 'Sh') {
                return 'role-red';
            }
            // Black team roles
            if (roleCode === 'Ma' || roleCode === 'Mf' || roleCode === 'D') {
                return 'role-black';
            }
            return '';
        }

        // Render role detail rows
        function renderRoleDetailRows(roleStats, parentRowIndex, player1Name, player2Name) {
            // Define all possible role combinations based on parent row type
            let allCombinations = [];
            
            if (parentRowIndex === 0) { // red-red
                allCombinations = ['M-M', 'M-Sh', 'Sh-M'];
            } else if (parentRowIndex === 1) { // black-black
                allCombinations = ['Ma-Ma', 'Ma-D', 'D-Ma'];
            } else if (parentRowIndex === 2) { // red-black
                allCombinations = ['M-Ma', 'M-D', 'Sh-Ma', 'Sh-D'];
            } else if (parentRowIndex === 3) { // black-red
                allCombinations = ['Ma-M', 'Ma-Sh', 'D-M', 'D-Sh'];
            }

            let detailRows = '';
            allCombinations.forEach(roleKey => {
                const [p1Role, p2Role] = roleKey.split('-');
                const stats = roleStats && roleStats[roleKey] ? roleStats[roleKey] : { wins: 0, losses: 0 };
                const total = stats.wins + stats.losses;
                
                const p1RoleName = getRoleDisplayName(p1Role);
                const p2RoleName = getRoleDisplayName(p2Role);
                const p1ColorClass = getRoleColorClass(p1Role);
                const p2ColorClass = getRoleColorClass(p2Role);
                
                // Determine which color class to use based on the parent row
                let colorClass = 'stat-bar-red';
                if (parentRowIndex === 1) colorClass = 'stat-bar-black'; // both-black
                else if (parentRowIndex === 3) colorClass = 'stat-bar-black'; // p1-black-p2-red
                
                let tooltipText = '';
                if (total > 0) {
                    const winsForm = getWinsForm(stats.wins);
                    const gamesForm = getGamesForm(total);
                    const winPct = (stats.wins / total * 100).toFixed(1);
                    tooltipText = `${p1RoleName} | ${p2RoleName}: ${stats.wins} ${winsForm} у ${total} ${gamesForm} (${winPct}%)`;
                } else {
                    tooltipText = `${p1RoleName} | ${p2RoleName}: 0 гульняў`;
                }
                
                // For parentRowIndex 3 (player 1 black, player 2 red), swap wins and losses to match the parent row display
                const displayWins = parentRowIndex === 3 ? stats.losses : stats.wins;
                const displayLosses = parentRowIndex === 3 ? stats.wins : stats.losses;
                
                detailRows += `
                    <tr class="detail-row" data-parent-row="${parentRowIndex}">
                        <td class="role-detail ${p1ColorClass}">${p1RoleName}</td>
                        <td class="role-detail ${p2ColorClass}">${p2RoleName}</td>
                        <td>${renderStatBar(displayWins, displayLosses, colorClass, `${parentRowIndex}-${roleKey}`, {
                            rowType: 'role-detail',
                            player1: player1Name,
                            player2: player2Name,
                            customTooltip: tooltipText
                        })}</td>
                    </tr>
                `;
            });
            
            return detailRows;
        }

        // Render stat bar
        function renderStatBar(wins, losses, winColorClass, rowIndex, tooltipData, useGrey = false, customColors = null) {
            const total = wins + losses;
            if (total === 0) {
                return '<div class="stat-bar-container"><div class="stat-bar-segment" style="width: 100%; background: #95a5a6;">0</div></div>';
            }

            const winPercent = (wins / total * 100);
            const lossPercent = (losses / total * 100);
            
            // Use custom colors for specific summary rows, grey for default summary, or normal colors
            let finalWinColorClass, finalLossColorClass, winColor, lossColor;
            if (customColors) {
                finalWinColorClass = customColors.win;
                finalLossColorClass = customColors.loss;
                winColor = customColors.winColor || 'custom';
                lossColor = customColors.lossColor || 'custom';
            } else if (useGrey) {
                finalWinColorClass = 'stat-bar-grey';
                finalLossColorClass = 'stat-bar-grey';
                winColor = 'grey';
                lossColor = 'grey';
            } else {
                finalWinColorClass = winColorClass;
                finalLossColorClass = winColorClass === 'stat-bar-red' ? 'stat-bar-black' : 'stat-bar-red';
                winColor = winColorClass === 'stat-bar-red' ? 'red' : 'black';
                lossColor = finalLossColorClass === 'stat-bar-red' ? 'red' : 'black';
            }

            // Generate tooltip text
            let tooltipText = '';
            if (tooltipData) {
                // Check for custom tooltip first
                if (tooltipData.customTooltip) {
                    tooltipText = tooltipData.customTooltip;
                } else {
                    const { rowType, player1, player2 } = tooltipData;
                    const winsForm = getWinsForm(wins);
                    const gamesForm = getGamesForm(total);
                    const winPct = winPercent.toFixed(1);
                    const lossPct = lossPercent.toFixed(1);
                    
                    if (rowType === 'both-red') {
                        tooltipText = `Разам за чырвоных: ${wins} ${winsForm} у ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'p1-red-p2-black') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `${player1} за чырвоных: ${wins} ${winsForm} (${winPct}%) vs ${player2} за чорных: ${losses} ${lossesForm} (${lossPct}%) у ${total} ${gamesForm}`;
                    } else if (rowType === 'p1-black-p2-red') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `${player1} за чорных: ${wins} ${winsForm} (${winPct}%) vs ${player2} за чырвоных: ${losses} ${lossesForm} (${lossPct}%) у ${total} ${gamesForm}`;
                    } else if (rowType === 'both-black') {
                        tooltipText = `Разам за чорных: ${wins} ${winsForm} у ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'summary-same') {
                        tooltipText = `Агулам за адзін колер: ${wins} ${winsForm} у ${total} ${gamesForm} (${winPct}%)`;
                    } else if (rowType === 'summary-diff') {
                        const lossesForm = getWinsForm(losses);
                        tooltipText = `Агулам за розныя колеры: ${player1}: ${wins} ${winsForm} (${winPct}%) vs ${player2}: ${losses} ${lossesForm} (${lossPct}%) у ${total} ${gamesForm}`;
                    }
                }
            }

            const titleAttr = tooltipText ? ` title="${tooltipText}"` : '';

            // Hide segments with 0 value
            let segments = '';
            let containerClass = 'stat-bar-container';
            
            if (wins > 0 && losses > 0) {
                // Add connector class for summary rows with custom colors
                if (customColors) {
                    containerClass += ' with-connector';
                }
                segments = `
                    <div class="stat-bar-segment ${finalWinColorClass}" style="width: ${winPercent}%;" data-color="${winColor}" data-row="${rowIndex}">${wins}</div>
                    <div class="stat-bar-segment ${finalLossColorClass}" style="width: ${lossPercent}%;" data-color="${lossColor}" data-row="${rowIndex}">${losses}</div>
                `;
            } else if (wins > 0) {
                segments = `<div class="stat-bar-segment ${finalWinColorClass}" style="width: 100%;" data-color="${winColor}" data-row="${rowIndex}">${wins}</div>`;
            } else if (losses > 0) {
                segments = `<div class="stat-bar-segment ${finalLossColorClass}" style="width: 100%;" data-color="${lossColor}" data-row="${rowIndex}">${losses}</div>`;
            }

            return `
                <div class="${containerClass}"${titleAttr}>
                    ${segments}
                </div>
            `;
        }

        // Render personal stats table
        function renderPersonalStatsTable(h2hStats, player1Name, player2Name) {
            // Calculate summary stats
            const sameColorWins = h2hStats.redRed.wins + h2hStats.blackBlack.wins;
            const sameColorLosses = h2hStats.redRed.losses + h2hStats.blackBlack.losses;
            const sameColorTotal = sameColorWins + sameColorLosses;
            
            const diffColorWins = h2hStats.redBlack.wins + h2hStats.blackRed.losses;
            const diffColorLosses = h2hStats.redBlack.losses + h2hStats.blackRed.wins;
            const diffColorTotal = diffColorWins + diffColorLosses;
            
            // Determine bar color for same color (red team wins if redRed has more wins)
            const sameColorBarClass = 'stat-bar-red';
            
            // For different colors, we need to determine which team won more
            // diffColorWins represents red team wins (redBlack.wins = P1 red won, blackRed.losses = P2 red won)
            const diffColorBarClass = 'stat-bar-red';
            
            const sameColorWinsForm = getWinsForm(sameColorWins);
            const sameColorGamesForm = getGamesForm(sameColorTotal);
            const sameColorPct = sameColorTotal > 0 ? (sameColorWins / sameColorTotal * 100).toFixed(1) : '0.0';
            const sameColorTooltip = sameColorTotal > 0 ? `Агулам за адзін колер: ${sameColorWins} ${sameColorWinsForm} у ${sameColorTotal} ${sameColorGamesForm} (${sameColorPct}%)` : '';
            
            const diffColorWinsForm = getWinsForm(diffColorWins);
            const diffColorGamesForm = getGamesForm(diffColorTotal);
            const diffColorPct = diffColorTotal > 0 ? (diffColorWins / diffColorTotal * 100).toFixed(1) : '0.0';
            const diffColorTooltip = diffColorTotal > 0 ? `Агулам за розныя колеры: ${diffColorWins} ${diffColorWinsForm} у ${diffColorTotal} ${diffColorGamesForm} (${diffColorPct}%)` : '';

            return `
                <div class="personal-stats-wrapper" style="overflow-x: auto; -webkit-overflow-scrolling: touch;">
                    <table class="personal-stats-table" id="personalStatsTable">
                        <thead>
                            <tr>
                                <th>${player1Name}</th>
                                <th>${player2Name}</th>
                                <th>Статыстыка</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr data-row="0" class="expandable-row" data-expandable="true">
                                <td data-color="red"><span class="expansion-indicator">▶</span> <span class="color-indicator color-red"></span></td>
                                <td data-color="red"><span class="color-indicator color-red"></span></td>
                                <td>${renderStatBar(h2hStats.redRed.wins, h2hStats.redRed.losses, 'stat-bar-red', 0, {
                                    rowType: 'both-red',
                                    player1: player1Name,
                                    player2: player2Name
                                })}</td>
                            </tr>
                            ${renderRoleDetailRows(h2hStats.redRed.roles, 0, player1Name, player2Name)}
                            <tr data-row="1" class="expandable-row" data-expandable="true">
                                <td data-color="black"><span class="expansion-indicator">▶</span> <span class="color-indicator color-black"></span></td>
                                <td data-color="black"><span class="color-indicator color-black"></span></td>
                                <td>${renderStatBar(h2hStats.blackBlack.wins, h2hStats.blackBlack.losses, 'stat-bar-black', 1, {
                                    rowType: 'both-black',
                                    player1: player1Name,
                                    player2: player2Name
                                })}</td>
                            </tr>
                            ${renderRoleDetailRows(h2hStats.blackBlack.roles, 1, player1Name, player2Name)}
                            <tr class="summary-row" data-row="summary-same">
                                <td colspan="2">Агулам за адзін колер</td>
                                <td>${renderStatBar(sameColorWins, sameColorLosses, sameColorBarClass, 'summary-same', {
                                    rowType: 'summary-same',
                                    player1: player1Name,
                                    player2: player2Name
                                }, false, {
                                    win: 'stat-bar-gold',
                                    loss: 'stat-bar-silver',
                                    winColor: 'gold',
                                    lossColor: 'silver'
                                })}</td>
                            </tr>
                            <tr data-row="2" class="expandable-row" data-expandable="true">
                                <td data-color="red"><span class="expansion-indicator">▶</span> <span class="color-indicator color-red"></span></td>
                                <td data-color="black"><span class="color-indicator color-black"></span></td>
                                <td>${renderStatBar(h2hStats.redBlack.wins, h2hStats.redBlack.losses, 'stat-bar-red', 2, {
                                    rowType: 'p1-red-p2-black',
                                    player1: player1Name,
                                    player2: player2Name
                                })}</td>
                            </tr>
                            ${renderRoleDetailRows(h2hStats.redBlack.roles, 2, player1Name, player2Name)}
                            <tr data-row="3" class="expandable-row" data-expandable="true">
                                <td data-color="black"><span class="expansion-indicator">▶</span> <span class="color-indicator color-black"></span></td>
                                <td data-color="red"><span class="color-indicator color-red"></span></td>
                                <td>${renderStatBar(h2hStats.blackRed.losses, h2hStats.blackRed.wins, 'stat-bar-black', 3, {
                                    rowType: 'p1-black-p2-red',
                                    player1: player1Name,
                                    player2: player2Name
                                })}</td>
                            </tr>
                            ${renderRoleDetailRows(h2hStats.blackRed.roles, 3, player1Name, player2Name)}
                            <tr class="summary-row" data-row="summary-diff">
                                <td colspan="2">Агулам за розныя колеры</td>
                                <td>${renderStatBar(diffColorWins, diffColorLosses, diffColorBarClass, 'summary-diff', {
                                    rowType: 'summary-diff',
                                    player1: player1Name,
                                    player2: player2Name
                                }, false, {
                                    win: 'stat-bar-green',
                                    loss: 'stat-bar-blue',
                                    winColor: 'green',
                                    lossColor: 'blue'
                                })}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            `;
        }

        // Setup hover handlers for personal stats table
        function setupPersonalStatsHover() {
            const table = document.getElementById('personalStatsTable');
            if (!table) return;

            const segments = table.querySelectorAll('.stat-bar-segment');
            
            segments.forEach(segment => {
                segment.addEventListener('mouseenter', (e) => {
                    const color = e.target.dataset.color;
                    const rowIndex = e.target.dataset.row;
                    
                    // Highlight cells with matching color in the same row
                    const row = table.querySelector(`tr[data-row="${rowIndex}"]`);
                    if (row) {
                        const cells = row.querySelectorAll(`td[data-color="${color}"]`);
                        cells.forEach(cell => cell.classList.add('highlight'));
                    }
                });

                segment.addEventListener('mouseleave', (e) => {
                    // Remove all highlights
                    const highlightedCells = table.querySelectorAll('td.highlight');
                    highlightedCells.forEach(cell => cell.classList.remove('highlight'));
                });
            });
        }

        // Setup expansion handlers for personal stats table
        function setupPersonalStatsExpansion() {
            const table = document.getElementById('personalStatsTable');
            if (!table) return;

            const expandableRows = table.querySelectorAll('.expandable-row');
            
            expandableRows.forEach(row => {
                row.addEventListener('click', (e) => {
                    const rowIndex = row.dataset.row;
                    const detailRows = table.querySelectorAll(`.detail-row[data-parent-row="${rowIndex}"]`);
                    const indicator = row.querySelector('.expansion-indicator');
                    
                    if (!detailRows.length) return; // No detail rows to expand
                    
                    // Check if currently expanded
                    const isExpanded = detailRows[0].classList.contains('expanded');
                    
                    if (isExpanded) {
                        // Collapse
                        detailRows.forEach(detailRow => {
                            detailRow.classList.remove('expanded');
                        });
                        if (indicator) indicator.textContent = '▶';
                        row.classList.remove('expanded');
                    } else {
                        // Expand current row (multiple rows can be expanded at once)
                        detailRows.forEach(detailRow => {
                            detailRow.classList.add('expanded');
                        });
                        if (indicator) indicator.textContent = '▼';
                        row.classList.add('expanded');
                    }
                });
                
                // Add visual feedback on hover
                row.style.cursor = 'pointer';
            });
        }

        // Render summary stats table
        function renderSummaryTable(stats) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100).toFixed(1) : '0.0';
            };

            return `
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th style="text-align: center;">Роля</th>
                            <th>Перамогі</th>
                            <th>Паразы</th>
                            <th>Гульні</th>
                            <th>%</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Мірны жыхар</td>
                            <td class="win-cell">${stats.byRole.M.wins}</td>
                            <td class="loss-cell">${stats.byRole.M.losses}</td>
                            <td>${stats.byRole.M.wins + stats.byRole.M.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.M.wins, stats.byRole.M.losses)}%</td>
                        </tr>
                        <tr>
                            <td>Шэрыф</td>
                            <td class="win-cell">${stats.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats.byRole.Sh.losses}</td>
                            <td>${stats.byRole.Sh.wins + stats.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.Sh.wins, stats.byRole.Sh.losses)}%</td>
                        </tr>
                        <tr class="team-row">
                            <td>Агулам за чырвоных</td>
                            <td class="win-cell">${stats.red.wins}</td>
                            <td class="loss-cell">${stats.red.losses}</td>
                            <td>${stats.red.wins + stats.red.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.red.wins, stats.red.losses)}%</td>
                        </tr>
                        <tr>
                            <td>Мафія</td>
                            <td class="win-cell">${stats.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats.byRole.Mf.losses}</td>
                            <td>${stats.byRole.Mf.wins + stats.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.Mf.wins, stats.byRole.Mf.losses)}%</td>
                        </tr>
                        <tr>
                            <td>Дон</td>
                            <td class="win-cell">${stats.byRole.D.wins}</td>
                            <td class="loss-cell">${stats.byRole.D.losses}</td>
                            <td>${stats.byRole.D.wins + stats.byRole.D.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.byRole.D.wins, stats.byRole.D.losses)}%</td>
                        </tr>
                        <tr class="team-row">
                            <td>Агулам за чорных</td>
                            <td class="win-cell">${stats.black.wins}</td>
                            <td class="loss-cell">${stats.black.losses}</td>
                            <td>${stats.black.wins + stats.black.losses}</td>
                            <td class="percentage-cell">${calcPct(stats.black.wins, stats.black.losses)}%</td>
                        </tr>
                        <tr class="total-row">
                            <td>Усяго</td>
                            <td class="win-cell">${stats.total.wins}</td>
                            <td class="loss-cell">${stats.total.losses}</td>
                            <td>${stats.total.wins + stats.total.losses}</td>
                            <td class="percentage-cell">${stats.total.winPct.toFixed(1)}%</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Render partner and opponent stats table with pagination
        function renderPartnerOpponentTable(partnerStats, page = 1) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100).toFixed(1) : '0.0';
            };

            // Filter out hidden players from partner stats
            partnerStats = partnerStats.filter(partner => {
                const playerObj = playerData.find(p => p.name === partner.name);
                return !playerObj || !playerObj.isHidden;
            });

            if (!partnerStats || partnerStats.length === 0) {
                return '<p>Няма дадзеных для адлюстравання</p>';
            }

            currentPartnerPage = page;

            // Check if mobile
            const isMobile = window.innerWidth <= 768;

            // Calculate pagination
            const totalPages = Math.ceil(partnerStats.length / partnersPerPage);
            const startIdx = (page - 1) * partnersPerPage;
            const endIdx = startIdx + partnersPerPage;
            const paginatedPartners = partnerStats.slice(startIdx, endIdx);

            // Mobile: render based on current section mode
            if (isMobile) {
                const sectionNames = {
                    'together': 'Разам',
                    'against': 'Супраць',
                    'total': 'Агулам'
                };

                const columnPrefixes = {
                    'together': 'together',
                    'against': 'against',
                    'total': 'total'
                };

                const currentSection = partnerSectionMode;
                const currentSectionName = sectionNames[currentSection];
                const columnPrefix = columnPrefixes[currentSection];

                const rows = paginatedPartners.map(player => {
                    const data = player[columnPrefix];
                    return `
                        <tr>
                            <td class="partner-player-cell" style="text-align: left;" onclick="compareWithPlayer('${player.name.replace(/'/g, "\\'")}')">
                                <span class="partner-player-name">${player.name}</span>
                            </td>
                            <td class="win-cell">${data.wins}</td>
                            <td class="loss-cell">${data.losses}</td>
                            <td>${data.total}</td>
                            <td class="percentage-cell">${calcPct(data.wins, data.losses)}%</td>
                        </tr>
                    `;
                }).join('');

                // Pagination controls
                const paginationHTML = partnerStats.length > partnersPerPage ? `
                    <div class="pagination">
                        <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(1)">«</button>
                        <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(${page - 1})">‹</button>
                        <span class="pagination-info">Старонка ${page} з ${totalPages} (усяго гульцоў: ${partnerStats.length})</span>
                        <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${page + 1})">›</button>
                        <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${totalPages})">»</button>
                    </div>
                ` : '';

                return `
                    <div class="partner-section-nav" style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px; gap: 10px;">
                        <button class="pagination-btn" onclick="switchPartnerSection('prev')" style="font-size: 1.2em;">‹</button>
                        <span style="font-size: 1.1em; font-weight: 600; min-width: 100px; text-align: center;">${currentSectionName}</span>
                        <button class="pagination-btn" onclick="switchPartnerSection('next')" style="font-size: 1.2em;">›</button>
                    </div>
                    <table class="stats-table" id="partnerOpponentTable">
                        <thead>
                            <tr>
                                <th style="text-align: center;">Гулец</th>
                                <th>Перамогі</th>
                                <th>Паразы</th>
                                <th>Гульні</th>
                                <th>%</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                    ${paginationHTML}
                `;
            }

            // Desktop: render all sections
            const rows = paginatedPartners.map(player => {
                return `
                    <tr>
                        <td class="partner-player-cell" style="text-align: left;" onclick="compareWithPlayer('${player.name.replace(/'/g, "\\'")}')">
                            <span class="partner-player-name">${player.name}</span>
                        </td>
                        <td class="win-cell">${player.together.wins}</td>
                        <td class="loss-cell">${player.together.losses}</td>
                        <td>${player.together.total}</td>
                        <td class="percentage-cell">${calcPct(player.together.wins, player.together.losses)}%</td>
                        <td class="win-cell">${player.against.wins}</td>
                        <td class="loss-cell">${player.against.losses}</td>
                        <td>${player.against.total}</td>
                        <td class="percentage-cell">${calcPct(player.against.wins, player.against.losses)}%</td>
                        <td class="win-cell">${player.total.wins}</td>
                        <td class="loss-cell">${player.total.losses}</td>
                        <td>${player.total.total}</td>
                        <td class="percentage-cell">${calcPct(player.total.wins, player.total.losses)}%</td>
                    </tr>
                `;
            }).join('');

            // Pagination controls
            const paginationHTML = partnerStats.length > partnersPerPage ? `
                <div class="pagination">
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(1)">«</button>
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToPartnerPage(${page - 1})">‹</button>
                    <span class="pagination-info">Старонка ${page} з ${totalPages} (усяго гульцоў: ${partnerStats.length})</span>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${page + 1})">›</button>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToPartnerPage(${totalPages})">»</button>
                </div>
            ` : '';

            return `
                <table class="stats-table" id="partnerOpponentTable">
                    <thead>
                        <tr>
                            <th rowspan="2" style="text-align: center;">Гулец</th>
                            <th colspan="4">Разам</th>
                            <th colspan="4">Супраць</th>
                            <th colspan="4">Агулам</th>
                        </tr>
                        <tr>
                            <th class="sortable" data-column="togetherWins" title="Перамогі разам" style="min-width: 80px;">Перамогі</th>
                            <th class="sortable" data-column="togetherLosses" title="Паразы разам" style="min-width: 80px;">Паразы</th>
                            <th class="sortable" data-column="togetherTotal" title="Усяго разам" style="min-width: 80px;">Гульні</th>
                            <th class="sortable" data-column="togetherPct" title="Працэнт перамог разам" style="min-width: 60px;">%</th>
                            <th class="sortable" data-column="againstWins" title="Перамогі супраць" style="min-width: 80px;">Перамогі</th>
                            <th class="sortable" data-column="againstLosses" title="Паразы супраць" style="min-width: 80px;">Паразы</th>
                            <th class="sortable" data-column="againstTotal" title="Усяго супраць" style="min-width: 80px;">Гульні</th>
                            <th class="sortable" data-column="againstPct" title="Працэнт перамог супраць" style="min-width: 60px;">%</th>
                            <th class="sortable" data-column="totalWins" title="Усяго перамог" style="min-width: 80px;">Перамогі</th>
                            <th class="sortable" data-column="totalLosses" title="Усяго параз" style="min-width: 80px;">Паразы</th>
                            <th class="sortable" data-column="totalTotal" title="Усяго гульняў" style="min-width: 80px;">Гульні</th>
                            <th class="sortable" data-column="totalPct" title="Агульны працэнт перамог" style="min-width: 60px;">%</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
                ${paginationHTML}
            `;
        }

        // Navigate to a specific partner page
        function goToPartnerPage(page) {
            const partnerSection = document.querySelector('.stats-section:has(#partnerOpponentTable)');
            if (partnerSection) {
                const newTableHTML = renderPartnerOpponentTable(partnerTableData, page);
                partnerSection.innerHTML = `<h3>Партнёры і супернікі</h3>${newTableHTML}`;
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            }
        }

        // Switch partner table section mode (mobile only)
        function switchPartnerSection(direction) {
            const sections = ['together', 'against', 'total'];
            const currentIndex = sections.indexOf(partnerSectionMode);
            
            let newIndex;
            if (direction === 'next') {
                newIndex = (currentIndex + 1) % sections.length;
            } else if (direction === 'prev') {
                newIndex = (currentIndex - 1 + sections.length) % sections.length;
            }
            
            partnerSectionMode = sections[newIndex];
            
            // Re-render the partner table
            const partnerSection = document.querySelector('.stats-section:has(#partnerOpponentTable)');
            if (partnerSection) {
                const newTableHTML = renderPartnerOpponentTable(partnerTableData, currentPartnerPage);
                partnerSection.innerHTML = `<h3>Партнёры і супернікі</h3>${newTableHTML}`;
            }
        }

        // Sort partner/opponent table
        function sortPartnerTable(column) {
            if (partnerTableSort.column === column) {
                partnerTableSort.ascending = !partnerTableSort.ascending;
            } else {
                partnerTableSort.column = column;
                partnerTableSort.ascending = false; // Default to descending
                currentPartnerPage = 1; // Reset to first page when changing sort column
            }

            // Sort the data
            partnerTableData.sort((a, b) => {
                let aVal, bVal;
                
                // Handle different column types
                if (column === 'together' || column === 'against' || column === 'total') {
                    // Sort by total for section headers
                    aVal = a[column].total;
                    bVal = b[column].total;
                } else if (column.endsWith('Pct')) {
                    // Sort by percentage
                    const section = column.replace('Pct', '');
                    const aTotal = a[section].wins + a[section].losses;
                    const bTotal = b[section].wins + b[section].losses;
                    aVal = aTotal > 0 ? (a[section].wins / aTotal) : 0;
                    bVal = bTotal > 0 ? (b[section].wins / bTotal) : 0;
                } else {
                    // Sort by specific stat (wins, losses, total)
                    const parts = column.match(/^(together|against|total)(.+)$/);
                    if (parts) {
                        const section = parts[1];
                        const stat = parts[2].toLowerCase();
                        aVal = a[section][stat];
                        bVal = b[section][stat];
                    }
                }

                if (aVal === bVal) return 0;
                const comparison = aVal > bVal ? 1 : -1;
                return partnerTableSort.ascending ? comparison : -comparison;
            });

            // Re-render the table with current page
            const tableContainer = document.querySelector('.stats-section:has(#partnerOpponentTable)');
            if (tableContainer) {
                const newTableHTML = renderPartnerOpponentTable(partnerTableData, currentPartnerPage);
                tableContainer.innerHTML = `<h3>Партнёры і супернікі</h3>${newTableHTML}`;
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            }
        }

        // Update sort indicators for partner table
        function updatePartnerTableSortIndicators() {
            const table = document.getElementById('partnerOpponentTable');
            if (!table) return;

            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
            });

            const sortedTh = table.querySelector(`th[data-column="${partnerTableSort.column}"]`);
            if (sortedTh) {
                sortedTh.classList.add(partnerTableSort.ascending ? 'sorted-asc' : 'sorted-desc');
            }
        }

        // Setup event listeners for partner table sorting
        function setupPartnerTableSorting() {
            const table = document.getElementById('partnerOpponentTable');
            if (!table) return;

            table.querySelectorAll('th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.column;
                    sortPartnerTable(column);
                });
            });
        }

        // Compare current player with clicked player from partner table
        function compareWithPlayer(clickedPlayerName) {
            if (!selectedPlayer1) {
                console.error('No current player selected');
                return;
            }
            
            // Enter comparison mode
            comparisonMode = true;
            selectedPlayer2 = clickedPlayerName;
            
            // Update UI to show comparison mode
            document.getElementById('secondarySearchContainer').classList.add('show');
            document.getElementById('closeCompareBtn').style.display = 'flex';
            document.getElementById('compareBtn').style.display = 'none';
            document.getElementById('playerSearchInput2').value = clickedPlayerName;
            
            // Show comparison stats
            showComparisonStats(selectedPlayer1, selectedPlayer2);
        }

        // Render comparison stats table
        function renderComparisonTable(stats1, stats2, player1Name, player2Name) {
            const calcPct = (wins, losses) => {
                const total = wins + losses;
                return total > 0 ? (wins / total * 100) : 0;
            };

            const isMobile = window.innerWidth <= 768;

            const formatPercent = (thisPct, otherPct, value) => {
                if (isMobile) {
                    // Mobile: use bold for larger value
                    if (thisPct > otherPct) {
                        return `<strong>${value}%</strong>`;
                    } else if (thisPct === otherPct) {
                        return `<strong>${value}%</strong>`;
                    }
                    return `${value}%`;
                } else {
                    // Desktop: use star for larger value
                    if (thisPct > otherPct && thisPct > 0) {
                        return `${value}% ⭐`;
                    }
                    return `${value}%`;
                }
            };

            // Calculate percentages for each row
            const mPct1 = calcPct(stats1.byRole.M.wins, stats1.byRole.M.losses);
            const mPct2 = calcPct(stats2.byRole.M.wins, stats2.byRole.M.losses);
            
            const shPct1 = calcPct(stats1.byRole.Sh.wins, stats1.byRole.Sh.losses);
            const shPct2 = calcPct(stats2.byRole.Sh.wins, stats2.byRole.Sh.losses);
            
            const redPct1 = calcPct(stats1.red.wins, stats1.red.losses);
            const redPct2 = calcPct(stats2.red.wins, stats2.red.losses);
            
            const mfPct1 = calcPct(stats1.byRole.Mf.wins, stats1.byRole.Mf.losses);
            const mfPct2 = calcPct(stats2.byRole.Mf.wins, stats2.byRole.Mf.losses);
            
            const dPct1 = calcPct(stats1.byRole.D.wins, stats1.byRole.D.losses);
            const dPct2 = calcPct(stats2.byRole.D.wins, stats2.byRole.D.losses);
            
            const blackPct1 = calcPct(stats1.black.wins, stats1.black.losses);
            const blackPct2 = calcPct(stats2.black.wins, stats2.black.losses);
            
            const totalPct1 = stats1.total.winPct;
            const totalPct2 = stats2.total.winPct;

            const roleColWidth = isMobile ? 'width: 35px !important; max-width: 35px !important; min-width: 35px !important;' : '';

            return `
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th rowspan="2" style="text-align: center; ${roleColWidth}">Роля</th>
                            <th colspan="4" class="player-column-header">${getDisplayName(player1Name)}</th>
                            <th colspan="4" class="player-column-header">${getDisplayName(player2Name)}</th>
                        </tr>
                        <tr>
                            <th style="text-align: center;">Перамогі</th>
                            <th>Паразы</th>
                            <th>Гульні</th>
                            <th>%</th>
                            <th style="text-align: center;">Перамогі</th>
                            <th>Паразы</th>
                            <th>Гульні</th>
                            <th>%</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="${roleColWidth}">Мірны жыхар</td>
                            <td class="win-cell">${stats1.byRole.M.wins}</td>
                            <td class="loss-cell">${stats1.byRole.M.losses}</td>
                            <td>${stats1.byRole.M.wins + stats1.byRole.M.losses}</td>
                            <td class="percentage-cell">${formatPercent(mPct1, mPct2, mPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.M.wins}</td>
                            <td class="loss-cell">${stats2.byRole.M.losses}</td>
                            <td>${stats2.byRole.M.wins + stats2.byRole.M.losses}</td>
                            <td class="percentage-cell">${formatPercent(mPct2, mPct1, mPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td style="${roleColWidth}">Шэрыф</td>
                            <td class="win-cell">${stats1.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats1.byRole.Sh.losses}</td>
                            <td>${stats1.byRole.Sh.wins + stats1.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${formatPercent(shPct1, shPct2, shPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.Sh.wins}</td>
                            <td class="loss-cell">${stats2.byRole.Sh.losses}</td>
                            <td>${stats2.byRole.Sh.wins + stats2.byRole.Sh.losses}</td>
                            <td class="percentage-cell">${formatPercent(shPct2, shPct1, shPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="team-row">
                            <td style="${roleColWidth}">Агулам за чырвоных</td>
                            <td class="win-cell">${stats1.red.wins}</td>
                            <td class="loss-cell">${stats1.red.losses}</td>
                            <td>${stats1.red.wins + stats1.red.losses}</td>
                            <td class="percentage-cell">${formatPercent(redPct1, redPct2, redPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.red.wins}</td>
                            <td class="loss-cell">${stats2.red.losses}</td>
                            <td>${stats2.red.wins + stats2.red.losses}</td>
                            <td class="percentage-cell">${formatPercent(redPct2, redPct1, redPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td style="${roleColWidth}">Мафія</td>
                            <td class="win-cell">${stats1.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats1.byRole.Mf.losses}</td>
                            <td>${stats1.byRole.Mf.wins + stats1.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${formatPercent(mfPct1, mfPct2, mfPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.Mf.wins}</td>
                            <td class="loss-cell">${stats2.byRole.Mf.losses}</td>
                            <td>${stats2.byRole.Mf.wins + stats2.byRole.Mf.losses}</td>
                            <td class="percentage-cell">${formatPercent(mfPct2, mfPct1, mfPct2.toFixed(1))}</td>
                        </tr>
                        <tr>
                            <td style="${roleColWidth}">Дон</td>
                            <td class="win-cell">${stats1.byRole.D.wins}</td>
                            <td class="loss-cell">${stats1.byRole.D.losses}</td>
                            <td>${stats1.byRole.D.wins + stats1.byRole.D.losses}</td>
                            <td class="percentage-cell">${formatPercent(dPct1, dPct2, dPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.byRole.D.wins}</td>
                            <td class="loss-cell">${stats2.byRole.D.losses}</td>
                            <td>${stats2.byRole.D.wins + stats2.byRole.D.losses}</td>
                            <td class="percentage-cell">${formatPercent(dPct2, dPct1, dPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="team-row">
                            <td style="${roleColWidth}">Агулам за чорных</td>
                            <td class="win-cell">${stats1.black.wins}</td>
                            <td class="loss-cell">${stats1.black.losses}</td>
                            <td>${stats1.black.wins + stats1.black.losses}</td>
                            <td class="percentage-cell">${formatPercent(blackPct1, blackPct2, blackPct1.toFixed(1))}</td>
                            <td class="win-cell">${stats2.black.wins}</td>
                            <td class="loss-cell">${stats2.black.losses}</td>
                            <td>${stats2.black.wins + stats2.black.losses}</td>
                            <td class="percentage-cell">${formatPercent(blackPct2, blackPct1, blackPct2.toFixed(1))}</td>
                        </tr>
                        <tr class="total-row">
                            <td style="font-weight: bold; ${roleColWidth}">Усяго</td>
                            <td class="win-cell" style="font-weight: bold;">${stats1.total.wins}</td>
                            <td class="loss-cell" style="font-weight: bold;">${stats1.total.losses}</td>
                            <td style="font-weight: bold;">${stats1.total.wins + stats1.total.losses}</td>
                            <td class="percentage-cell" style="font-weight: bold;">${formatPercent(totalPct1, totalPct2, totalPct1.toFixed(1))}</td>
                            <td class="win-cell" style="font-weight: bold;">${stats2.total.wins}</td>
                            <td class="loss-cell" style="font-weight: bold;">${stats2.total.losses}</td>
                            <td style="font-weight: bold;">${stats2.total.wins + stats2.total.losses}</td>
                            <td class="percentage-cell" style="font-weight: bold;">${formatPercent(totalPct2, totalPct1, totalPct2.toFixed(1))}</td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Pagination state
        let currentGamePage = 1;
        const gamesPerPage = 20;
        let allGames = [];

        // Partner table pagination state
        let currentPartnerPage = 1;
        const partnersPerPage = 20;

        // Comparison games pagination state
        let comparisonCommonGames = [];
        let currentComparisonGamePage = 1;
        let comparisonPlayer1Name = '';
        let comparisonPlayer2Name = '';
        const comparisonGamesPerPage = 20;

        // Render games list table with pagination
        function renderGamesTable(games, page = 1) {
            allGames = games;
            currentGamePage = page;
            
            const formatDate = (dateStr) => {
                if (!dateStr) return '—';
                const date = new Date(dateStr);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            };

            // Check if mobile
            const isMobile = window.innerWidth <= 768;

            // Short role names for mobile
            const shortRoleNames = {
                'M': 'М',
                'Sh': 'Ш',
                'Mf': 'МФ',
                'D': 'Д'
            };

            // Calculate pagination
            const totalPages = Math.ceil(games.length / gamesPerPage);
            const startIdx = (page - 1) * gamesPerPage;
            const endIdx = startIdx + gamesPerPage;
            const paginatedGames = games.slice(startIdx, endIdx);

            const rows = paginatedGames.map(game => {
                const gameNumber = game.game_number ? `#${game.game_number}` : `#${game.game_id}`;
                const roleName = isMobile 
                    ? (shortRoleNames[game.role_code] || game.role_code)
                    : (roleNames[game.role_code] || game.role_code);
                const resultText = isMobile
                    ? (game.player_won ? '+' : '−')
                    : (game.player_won ? 'Перамога' : 'Параза');
                return `
                    <tr>
                        <td>${gameNumber}</td>
                        <td>${formatDate(game.game_date)}</td>
                        <td>${roleName}</td>
                        <td class="${game.player_won ? 'win-badge' : 'loss-badge'}">
                            ${resultText}
                        </td>
                    </tr>
                `;
            }).join('');

            // Pagination controls
            const paginationHTML = games.length > gamesPerPage ? `
                <div class="pagination">
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToGamePage(1)">«</button>
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToGamePage(${page - 1})">‹</button>
                    <span class="pagination-info">Старонка ${page} з ${totalPages} (усяго гульняў: ${games.length})</span>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToGamePage(${page + 1})">›</button>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToGamePage(${totalPages})">»</button>
                </div>
            ` : '';

            return `
                <table class="games-table">
                    <thead>
                        <tr>
                            <th>Гульня</th>
                            <th>Дата</th>
                            <th>Роля</th>
                            <th>Вынік</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
                ${paginationHTML}
            `;
        }

        // Navigate to a specific game page
        function goToGamePage(page) {
            const gamesSection = document.querySelector('.stats-section:has(.games-table)');
            if (gamesSection) {
                const newTableHTML = renderGamesTable(allGames, page);
                gamesSection.innerHTML = `<h3>Гісторыя гульняў</h3>${newTableHTML}`;
            }
        }

        // Navigate to a specific comparison game page
        function goToComparisonGamePage(page) {
            // Find the comparison games section (it's the third stats-section in comparison mode)
            const allStatsSections = document.querySelectorAll('.stats-section');
            const comparisonGamesSection = allStatsSections[2]; // Third section (0-indexed)
            
            if (comparisonGamesSection && comparisonCommonGames.length > 0) {
                // Re-render the table with the new page
                // We need to reconstruct games1 and games2 from comparisonCommonGames
                const games1 = comparisonCommonGames.map(cg => cg.player1);
                const games2 = comparisonCommonGames.map(cg => cg.player2);
                
                const newTableHTML = renderComparisonGamesTable(
                    games1, 
                    games2, 
                    comparisonPlayer1Name, 
                    comparisonPlayer2Name, 
                    page
                );
                comparisonGamesSection.innerHTML = `<h3>Гульні</h3>${newTableHTML}`;
            }
        }

        // Show player stats page
        async function showPlayerStats(playerName) {
            // Set player name in input field and update selected player
            document.getElementById('playerSearchInput').value = playerName;
            selectedPlayer1 = playerName;
            closeAutocomplete();
            
            // Update header title with player name
            document.getElementById('headerTitle').textContent = getDisplayName(playerName);
            
            // Show player stats page with loading state
            const playerStatsBody = document.getElementById('playerStatsBody');
            playerStatsBody.innerHTML = `
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>Загрузка статыстыкі...</p>
                </div>
            `;
            showPlayerStatsView();

            try {
                // Fetch player games
                const games = await fetchPlayerGames(playerName);

                if (!games || games.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>Няма дадзеных для гульца</p>
                        </div>
                    `;
                    return;
                }

                // Calculate stats
                const stats = calculatePlayerStats(games);

                // Fetch all participants from the player's games for partner/opponent stats
                const gameIds = games.map(game => game.game_id);
                const allParticipants = await fetchGameParticipants(gameIds);
                const partnerStats = calculatePartnerOpponentStats(games, allParticipants);

                // Store partner data globally for sorting
                partnerTableData = partnerStats;
                partnerTableSort = { column: 'totalTotal', ascending: false };
                currentPartnerPage = 1;

                // Render player stats content
                playerStatsBody.innerHTML = `
                    <div class="stats-section">
                        <h3>Агульная статыстыка</h3>
                        ${renderSummaryTable(stats)}
                    </div>
                    <div class="stats-section">
                        <h3>Партнёры і супернікі</h3>
                        ${renderPartnerOpponentTable(partnerStats, 1)}
                    </div>
                    <div class="stats-section">
                        <h3>Гісторыя гульняў</h3>
                        ${renderGamesTable(games)}
                    </div>
                `;

                // Setup sorting for partner table
                setupPartnerTableSorting();
                updatePartnerTableSortIndicators();
            } catch (error) {
                console.error('Error loading player stats:', error);
                playerStatsBody.innerHTML = `
                    <div class="player-stats-loading">
                        <p style="color: #c0392b;">Памылка загрузкі: ${error.message}</p>
                    </div>
                `;
            }
        }

        // Render comparison games table showing games where both players participated
        function renderComparisonGamesTable(games1, games2, player1Name, player2Name, page = 1) {
            // Store player names for pagination
            comparisonPlayer1Name = player1Name;
            comparisonPlayer2Name = player2Name;
            
            // Find common games
            const player1GameMap = {};
            games1.forEach(game => {
                player1GameMap[game.game_id] = game;
            });

            const commonGames = [];
            games2.forEach(game => {
                if (player1GameMap[game.game_id]) {
                    commonGames.push({
                        player1: player1GameMap[game.game_id],
                        player2: game
                    });
                }
            });

            // Sort by date (newest first)
            commonGames.sort((a, b) => new Date(b.player1.game_date) - new Date(a.player1.game_date));

            // Store common games for pagination
            comparisonCommonGames = commonGames;
            currentComparisonGamePage = page;

            if (commonGames.length === 0) {
                return '<p>Няма агульных гульняў</p>';
            }

            const formatDate = (dateStr) => {
                if (!dateStr) return '—';
                const date = new Date(dateStr);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            };

            // Check if mobile
            const isMobile = window.innerWidth <= 768;

            // Short role names for mobile
            const shortRoleNames = {
                'M': 'М',
                'Sh': 'Ш',
                'Mf': 'МФ',
                'D': 'Д'
            };

            // Calculate pagination
            const totalPages = Math.ceil(commonGames.length / comparisonGamesPerPage);
            const startIdx = (page - 1) * comparisonGamesPerPage;
            const endIdx = startIdx + comparisonGamesPerPage;
            const paginatedGames = commonGames.slice(startIdx, endIdx);

            const rows = paginatedGames.map(({ player1, player2 }) => {
                const gameNumber = player1.game_number ? `#${player1.game_number}` : `#${player1.game_id}`;
                
                // Mobile: use short role names; Desktop: use full role names
                const p1Role = isMobile
                    ? (shortRoleNames[player1.role_code] || player1.role_code)
                    : (roleNames[player1.role_code] || player1.role_code);
                const p2Role = isMobile
                    ? (shortRoleNames[player2.role_code] || player2.role_code)
                    : (roleNames[player2.role_code] || player2.role_code);
                
                const redWon = !player1.mafia_won;
                
                // Mobile: show colored squares; Desktop: show text
                // Red for peaceful team, black for mafia
                const victoryText = isMobile 
                    ? (redWon ? '🟥' : '⬛')
                    : (redWon ? 'Мір' : 'Мафія');
                const victoryColor = redWon ? '#c0392b' : '#000000';
                
                // Check if each player won
                const p1Won = player1.player_won;
                const p2Won = player2.player_won;
                
                // Function to get role color on mobile: М and Ш = red, МФ and Д = black
                const getRoleColor = (roleCode) => {
                    if (!isMobile) return '';
                    if (roleCode === 'M' || roleCode === 'Sh') return '#c0392b'; // Red for city
                    if (roleCode === 'Mf' || roleCode === 'D') return '#000000'; // Black for mafia
                    return '';
                };
                
                const p1Color = getRoleColor(player1.role_code);
                const p2Color = getRoleColor(player2.role_code);
                
                // Apply bold to winning roles and color on mobile
                const p1RoleFormatted = p1Won 
                    ? `<strong style="${p1Color ? `color: ${p1Color};` : ''}">${p1Role}</strong>` 
                    : (p1Color ? `<span style="color: ${p1Color};">${p1Role}</span>` : p1Role);
                const p2RoleFormatted = p2Won 
                    ? `<strong style="${p2Color ? `color: ${p2Color};` : ''}">${p2Role}</strong>` 
                    : (p2Color ? `<span style="color: ${p2Color};">${p2Role}</span>` : p2Role);
                
                return `
                    <tr>
                        <td>${gameNumber}</td>
                        <td>${formatDate(player1.game_date)}</td>
                        <td>${p1RoleFormatted}</td>
                        <td>${p2RoleFormatted}</td>
                        <td style="color: ${victoryColor}; font-weight: 600; font-size: ${isMobile ? '16px' : 'inherit'};">${victoryText}</td>
                    </tr>
                `;
            }).join('');

            // Pagination controls
            const paginationHTML = commonGames.length > comparisonGamesPerPage ? `
                <div class="pagination">
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToComparisonGamePage(1)">«</button>
                    <button class="pagination-btn" ${page === 1 ? 'disabled' : ''} onclick="goToComparisonGamePage(${page - 1})">‹</button>
                    <span class="pagination-info">Старонка ${page} з ${totalPages} (усяго гульняў: ${commonGames.length})</span>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToComparisonGamePage(${page + 1})">›</button>
                    <button class="pagination-btn" ${page === totalPages ? 'disabled' : ''} onclick="goToComparisonGamePage(${totalPages})">»</button>
                </div>
            ` : '';

            return `
                <table class="games-table">
                    <thead>
                        <tr>
                            <th>Гульня</th>
                            <th>Дата</th>
                            <th>${player1Name}</th>
                            <th>${player2Name}</th>
                            <th>Перамога</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
                ${paginationHTML}
            `;
        }

        // Show comparison stats for two players
        async function showComparisonStats(player1Name, player2Name) {
            // Update header title with both player names
            document.getElementById('headerTitle').textContent = `${getDisplayName(player1Name)} vs ${getDisplayName(player2Name)}`;
            
            const playerStatsBody = document.getElementById('playerStatsBody');
            playerStatsBody.innerHTML = `
                <div class="player-stats-loading">
                    <div class="spinner"></div>
                    <p>Загрузка параўнання...</p>
                </div>
            `;

            try {
                // Fetch both players' games
                const [games1, games2] = await Promise.all([
                    fetchPlayerGames(player1Name),
                    fetchPlayerGames(player2Name)
                ]);

                if (!games1 || games1.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>Няма дадзеных для гульца ${getDisplayName(player1Name)}</p>
                        </div>
                    `;
                    return;
                }

                if (!games2 || games2.length === 0) {
                    playerStatsBody.innerHTML = `
                        <div class="player-stats-loading">
                            <p>Няма дадзеных для гульца ${getDisplayName(player2Name)}</p>
                        </div>
                    `;
                    return;
                }

                // Calculate stats for both players
                const stats1 = calculatePlayerStats(games1);
                const stats2 = calculatePlayerStats(games2);

                // Calculate head-to-head stats
                const h2hStats = calculateHeadToHeadStats(games1, games2);

                // Render comparison content
                playerStatsBody.innerHTML = `
                    <div class="stats-section">
                        <h3>Агульная статыстыка</h3>
                        ${renderComparisonTable(stats1, stats2, player1Name, player2Name)}
                    </div>
                    <div class="stats-section">
                        <h3>Персанальная статыстыка</h3>
                        ${renderPersonalStatsTable(h2hStats, player1Name, player2Name)}
                    </div>
                    <div class="stats-section">
                        <h3>Гульні</h3>
                        ${renderComparisonGamesTable(games1, games2, player1Name, player2Name)}
                    </div>
                `;

                // Setup hover and expansion handlers after content is rendered
                setupPersonalStatsHover();
                setupPersonalStatsExpansion();
            } catch (error) {
                console.error('Error loading comparison stats:', error);
                playerStatsBody.innerHTML = `
                    <div class="player-stats-loading">
                        <p style="color: #c0392b;">Памылка загрузкі: ${error.message}</p>
                    </div>
                `;
            }
        }

        async function loadData() {
            showStatus('Загрузка дадзеных...', 'info');

            try {
                // First, fetch the minimum games threshold from settings
                try {
                    const settingsUrl = `${SUPABASE_URL}/rest/v1/app_settings?key=eq.min_games_threshold`;
                    const settingsResponse = await fetch(settingsUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (settingsResponse.ok) {
                        const settingsData = await settingsResponse.json();
                        if (settingsData && settingsData.length > 0) {
                            const thresholdValue = parseInt(settingsData[0].value);
                            if (!isNaN(thresholdValue)) {
                                defaultMinGamesThreshold = thresholdValue;
                                console.log('✅ Loaded min games threshold from DB:', defaultMinGamesThreshold);
                            }
                        }
                    }
                } catch (error) {
                    console.log('⚠️ Could not load threshold from DB, using default (25):', error);
                    // Keep default value of 25
                }
                
                // Fetch the activity period from settings
                try {
                    const activitySettingsUrl = `${SUPABASE_URL}/rest/v1/app_settings?key=eq.activity_period_days`;
                    const activitySettingsResponse = await fetch(activitySettingsUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                        }
                    });
                    
                    if (activitySettingsResponse.ok) {
                        const activitySettingsData = await activitySettingsResponse.json();
                        if (activitySettingsData && activitySettingsData.length > 0) {
                            const activityPeriodValue = parseInt(activitySettingsData[0].value);
                            if (!isNaN(activityPeriodValue)) {
                                activityPeriodDays = activityPeriodValue;
                                console.log('✅ Loaded activity period from DB:', activityPeriodDays);
                            }
                        }
                    }
                } catch (error) {
                    console.log('⚠️ Could not load activity period from DB, using default (30):', error);
                    // Keep default value of 30
                }
                
                // Fetch all data with pagination to ensure we get everything
                let allData = [];
                let pageSize = 1000;
                let currentPage = 0;
                let hasMore = true;
                
                while (hasMore) {
                    const rangeStart = currentPage * pageSize;
                    const rangeEnd = rangeStart + pageSize - 1;
                    
                    const apiUrl = `${SUPABASE_URL}/rest/v1/player_games_view?select=*`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: {
                            'apikey': SUPABASE_ANON_KEY,
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'Range': `${rangeStart}-${rangeEnd}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Памылка загрузкі дадзеных. Статус: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (!data || data.length === 0) {
                        if (currentPage === 0) {
                            throw new Error('Няма дадзеных у базе. Запусціце import_games.py для загрузкі дадзеных.');
                        }
                        break;
                    }
                    
                    allData = allData.concat(data);
                    console.log(`Loaded page ${currentPage + 1}: ${data.length} games (total so far: ${allData.length})`);
                    
                    // If we got less than pageSize, we've reached the end
                    if (data.length < pageSize) {
                        hasMore = false;
                    } else {
                        currentPage++;
                    }
                }

                showStatus('Апрацоўка дадзеных...', 'info');

                // Store all games data
                allGamesData = allData;
                console.log('✅ Loaded', allGamesData.length, 'games total');

                // Calculate player stats from all games
                playerData = calculatePlayerDataFromGames(allGamesData);
                
                // Enrich with hidden status from player table
                playerData = await enrichPlayerDataWithHiddenStatus(playerData);
                filteredPlayerData = [...playerData];

                // Sort by win percentage descending by default
                currentSort = { column: 'winPct', ascending: true };
                sortData('winPct');

                // Hide status message and show filters and table
                document.getElementById('status').classList.remove('show');
                document.getElementById('filtersContainer').style.display = 'block';
                document.getElementById('tableControls').style.display = '';
                document.getElementById('tableWrapper').style.display = 'block';

                // Add click handlers to column headers
                document.querySelectorAll('th.sortable').forEach(th => {
                    th.addEventListener('click', () => {
                        const column = th.dataset.column;
                        sortData(column);
                    });
                });

                // Setup filter handlers
                setupFiltersToggle();
                setupPlayerFilter();
                setupGamesFilter();
                setupDateFilter();
                setupActivePlayersFilter();

            } catch (error) {
                console.error('Памылка:', error);
                showStatus('Памылка: ' + error.message, 'error');
            }
        }

        // Load data automatically when page loads
        window.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>
</html>
